diff --unified --recursive --new-file usbdrv/oddebug.c /home/klaute/dev/avr/HackStick/firmware/usbdrv/oddebug.c
--- usbdrv/oddebug.c	2010-07-27 19:39:24.000000000 +0200
+++ /home/klaute/dev/avr/HackStick/firmware/usbdrv/oddebug.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/* Name: oddebug.c
- * Project: AVR library
- * Author: Christian Starkjohann
- * Creation Date: 2005-01-16
- * Tabsize: 4
- * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
- * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
- * This Revision: $Id: oddebug.c 692 2008-11-07 15:07:40Z cs $
- */
-
-#include "oddebug.h"
-
-#if DEBUG_LEVEL > 0
-
-#warning "Never compile production devices with debugging enabled"
-
-static void uartPutc(char c)
-{
-    while(!(ODDBG_USR & (1 << ODDBG_UDRE)));    /* wait for data register empty */
-    ODDBG_UDR = c;
-}
-
-static uchar    hexAscii(uchar h)
-{
-    h &= 0xf;
-    if(h >= 10)
-        h += 'a' - (uchar)10 - '0';
-    h += '0';
-    return h;
-}
-
-static void printHex(uchar c)
-{
-    uartPutc(hexAscii(c >> 4));
-    uartPutc(hexAscii(c));
-}
-
-void    odDebug(uchar prefix, uchar *data, uchar len)
-{
-    printHex(prefix);
-    uartPutc(':');
-    while(len--){
-        uartPutc(' ');
-        printHex(*data++);
-    }
-    uartPutc('\r');
-    uartPutc('\n');
-}
-
-#endif
diff --unified --recursive --new-file usbdrv/oddebug.h /home/klaute/dev/avr/HackStick/firmware/usbdrv/oddebug.h
--- usbdrv/oddebug.h	2010-07-27 19:39:24.000000000 +0200
+++ /home/klaute/dev/avr/HackStick/firmware/usbdrv/oddebug.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,123 +0,0 @@
-/* Name: oddebug.h
- * Project: AVR library
- * Author: Christian Starkjohann
- * Creation Date: 2005-01-16
- * Tabsize: 4
- * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
- * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
- * This Revision: $Id: oddebug.h 692 2008-11-07 15:07:40Z cs $
- */
-
-#ifndef __oddebug_h_included__
-#define __oddebug_h_included__
-
-/*
-General Description:
-This module implements a function for debug logs on the serial line of the
-AVR microcontroller. Debugging can be configured with the define
-'DEBUG_LEVEL'. If this macro is not defined or defined to 0, all debugging
-calls are no-ops. If it is 1, DBG1 logs will appear, but not DBG2. If it is
-2, DBG1 and DBG2 logs will be printed.
-
-A debug log consists of a label ('prefix') to indicate which debug log created
-the output and a memory block to dump in hex ('data' and 'len').
-*/
-
-
-#ifndef F_CPU
-#   define  F_CPU   12000000    /* 12 MHz */
-#endif
-
-/* make sure we have the UART defines: */
-#include "usbportability.h"
-
-#ifndef uchar
-#   define  uchar   unsigned char
-#endif
-
-#if DEBUG_LEVEL > 0 && !(defined TXEN || defined TXEN0) /* no UART in device */
-#   warning "Debugging disabled because device has no UART"
-#   undef   DEBUG_LEVEL
-#endif
-
-#ifndef DEBUG_LEVEL
-#   define  DEBUG_LEVEL 0
-#endif
-
-/* ------------------------------------------------------------------------- */
-
-#if DEBUG_LEVEL > 0
-#   define  DBG1(prefix, data, len) odDebug(prefix, data, len)
-#else
-#   define  DBG1(prefix, data, len)
-#endif
-
-#if DEBUG_LEVEL > 1
-#   define  DBG2(prefix, data, len) odDebug(prefix, data, len)
-#else
-#   define  DBG2(prefix, data, len)
-#endif
-
-/* ------------------------------------------------------------------------- */
-
-#if DEBUG_LEVEL > 0
-extern void odDebug(uchar prefix, uchar *data, uchar len);
-
-/* Try to find our control registers; ATMEL likes to rename these */
-
-#if defined UBRR
-#   define  ODDBG_UBRR  UBRR
-#elif defined UBRRL
-#   define  ODDBG_UBRR  UBRRL
-#elif defined UBRR0
-#   define  ODDBG_UBRR  UBRR0
-#elif defined UBRR0L
-#   define  ODDBG_UBRR  UBRR0L
-#endif
-
-#if defined UCR
-#   define  ODDBG_UCR   UCR
-#elif defined UCSRB
-#   define  ODDBG_UCR   UCSRB
-#elif defined UCSR0B
-#   define  ODDBG_UCR   UCSR0B
-#endif
-
-#if defined TXEN
-#   define  ODDBG_TXEN  TXEN
-#else
-#   define  ODDBG_TXEN  TXEN0
-#endif
-
-#if defined USR
-#   define  ODDBG_USR   USR
-#elif defined UCSRA
-#   define  ODDBG_USR   UCSRA
-#elif defined UCSR0A
-#   define  ODDBG_USR   UCSR0A
-#endif
-
-#if defined UDRE
-#   define  ODDBG_UDRE  UDRE
-#else
-#   define  ODDBG_UDRE  UDRE0
-#endif
-
-#if defined UDR
-#   define  ODDBG_UDR   UDR
-#elif defined UDR0
-#   define  ODDBG_UDR   UDR0
-#endif
-
-static inline void  odDebugInit(void)
-{
-    ODDBG_UCR |= (1<<ODDBG_TXEN);
-    ODDBG_UBRR = F_CPU / (19200 * 16L) - 1;
-}
-#else
-#   define odDebugInit()
-#endif
-
-/* ------------------------------------------------------------------------- */
-
-#endif /* __oddebug_h_included__ */
BinÃ¤rdateien usbdrv/oddebug.o and /home/klaute/dev/avr/HackStick/firmware/usbdrv/oddebug.o sind verschieden.
diff --unified --recursive --new-file usbdrv/usbdrvasm.asm /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrvasm.asm
--- usbdrv/usbdrvasm.asm	2010-07-27 19:39:24.000000000 +0200
+++ /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrvasm.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-/* Name: usbdrvasm.asm
- * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
- * Author: Christian Starkjohann
- * Creation Date: 2006-03-01
- * Tabsize: 4
- * Copyright: (c) 2006 by OBJECTIVE DEVELOPMENT Software GmbH
- * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
- * This Revision: $Id$
- */
-
-/*
-General Description:
-The IAR compiler/assembler system prefers assembler files with file extension
-".asm". We simply provide this file as an alias for usbdrvasm.S.
-
-Thanks to Oleg Semyonov for his help with the IAR tools port!
-*/
-
-#include "usbdrvasm.S"
-
-end
diff --unified --recursive --new-file usbdrv/usbdrvasm.lst /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrvasm.lst
--- usbdrv/usbdrvasm.lst	1970-01-01 01:00:00.000000000 +0100
+++ /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrvasm.lst	2011-03-02 11:51:55.000000000 +0100
@@ -0,0 +1,1550 @@
+   1               	# 1 "usbdrv/usbdrvasm.S"
+   1               	/* Name: usbdrvasm.S
+   0               	
+   0               	
+   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+   3               	 * Author: Christian Starkjohann
+   4               	 * Creation Date: 2007-06-13
+   5               	 * Tabsize: 4
+   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+   8               	 * Revision: $Id: usbdrvasm.S 785 2010-05-30 17:57:07Z cs $
+   9               	 */
+  10               	
+  11               	/*
+  12               	General Description:
+  13               	This module is the assembler part of the USB driver. This file contains
+  14               	general code (preprocessor acrobatics and CRC computation) and then includes
+  15               	the file appropriate for the given clock rate.
+  16               	*/
+  17               	
+  18               	#define __SFR_OFFSET 0      /* used by avr-libc's register definitions */
+  19               	#include "usbportability.h"
+   1               	/* Name: usbportability.h
+   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+   3               	 * Author: Christian Starkjohann
+   4               	 * Creation Date: 2008-06-17
+   5               	 * Tabsize: 4
+   6               	 * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+   8               	 * This Revision: $Id: usbportability.h 785 2010-05-30 17:57:07Z cs $
+   9               	 */
+  10               	
+  11               	/*
+  12               	General Description:
+  13               	This header is intended to contain all (or at least most of) the compiler
+  14               	and library dependent stuff. The C code is written for avr-gcc and avr-libc.
+  15               	The API of other development environments is converted to gcc's and avr-libc's
+  16               	API by means of defines.
+  17               	
+  18               	This header also contains all system includes since they depend on the
+  19               	development environment.
+  20               	
+  21               	Thanks to Oleg Semyonov for his help with the IAR tools port!
+  22               	*/
+  23               	
+  24               	#ifndef __usbportability_h_INCLUDED__
+  25               	#define __usbportability_h_INCLUDED__
+  26               	
+  27               	/* We check explicitly for IAR and CodeVision. Default is avr-gcc/avr-libc. */
+  28               	
+  29               	/* ------------------------------------------------------------------------- */
+  30               	#if defined __IAR_SYSTEMS_ICC__ || defined __IAR_SYSTEMS_ASM__  /* check for IAR */
+  31               	/* ------------------------------------------------------------------------- */
+  32               	
+  33               	#ifndef ENABLE_BIT_DEFINITIONS
+  34               	#   define ENABLE_BIT_DEFINITIONS	1   /* Enable bit definitions */
+  35               	#endif
+  36               	
+  37               	/* Include IAR headers */
+  38               	#include <ioavr.h>
+  39               	#ifndef __IAR_SYSTEMS_ASM__
+  40               	#   include <inavr.h>
+  41               	#endif
+  42               	
+  43               	#define __attribute__(arg)  /* not supported on IAR */
+  44               	
+  45               	#ifdef __IAR_SYSTEMS_ASM__
+  46               	#   define __ASSEMBLER__    /* IAR does not define standard macro for asm */
+  47               	#endif
+  48               	
+  49               	#ifdef __HAS_ELPM__
+  50               	#   define PROGMEM __farflash
+  51               	#else
+  52               	#   define PROGMEM __flash
+  53               	#endif
+  54               	
+  55               	#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+  56               	
+  57               	/* The following definitions are not needed by the driver, but may be of some
+  58               	 * help if you port a gcc based project to IAR.
+  59               	 */
+  60               	#define cli()       __disable_interrupt()
+  61               	#define sei()       __enable_interrupt()
+  62               	#define wdt_reset() __watchdog_reset()
+  63               	#define _BV(x)      (1 << (x))
+  64               	
+  65               	/* assembler compatibility macros */
+  66               	#define nop2    rjmp    $+2 /* jump to next instruction */
+  67               	#define XL      r26
+  68               	#define XH      r27
+  69               	#define YL      r28
+  70               	#define YH      r29
+  71               	#define ZL      r30
+  72               	#define ZH      r31
+  73               	#define lo8(x)  LOW(x)
+  74               	#define hi8(x)  (((x)>>8) & 0xff)   /* not HIGH to allow XLINK to make a proper range check */
+  75               	
+  76               	/* Depending on the device you use, you may get problems with the way usbdrv.h
+  77               	 * handles the differences between devices. Since IAR does not use #defines
+  78               	 * for MCU registers, we can't check for the existence of a particular
+  79               	 * register with an #ifdef. If the autodetection mechanism fails, include
+  80               	 * definitions for the required USB_INTR_* macros in your usbconfig.h. See
+  81               	 * usbconfig-prototype.h and usbdrv.h for details.
+  82               	 */
+  83               	
+  84               	/* ------------------------------------------------------------------------- */
+  85               	#elif __CODEVISIONAVR__ /* check for CodeVision AVR */
+  86               	/* ------------------------------------------------------------------------- */
+  87               	/* This port is not working (yet) */
+  88               	
+  89               	/* #define F_CPU   _MCU_CLOCK_FREQUENCY_    seems to be defined automatically */
+  90               	
+  91               	#include <io.h>
+  92               	#include <delay.h>
+  93               	
+  94               	#define __attribute__(arg)  /* not supported on IAR */
+  95               	
+  96               	#define PROGMEM                 __flash
+  97               	#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+  98               	
+  99               	#ifndef __ASSEMBLER__
+ 100               	static inline void  cli(void)
+ 101               	{
+ 102               	    #asm("cli");
+ 103               	}
+ 104               	static inline void  sei(void)
+ 105               	{
+ 106               	    #asm("sei");
+ 107               	}
+ 108               	#endif
+ 109               	#define _delay_ms(t)    delay_ms(t)
+ 110               	#define _BV(x)          (1 << (x))
+ 111               	#define USB_CFG_USE_SWITCH_STATEMENT 1  /* macro for if() cascase fails for unknown reason */
+ 112               	
+ 113               	#define macro   .macro
+ 114               	#define endm    .endmacro
+ 115               	#define nop2    rjmp    .+0 /* jump to next instruction */
+ 116               	
+ 117               	/* ------------------------------------------------------------------------- */
+ 118               	#else   /* default development environment is avr-gcc/avr-libc */
+ 119               	/* ------------------------------------------------------------------------- */
+ 120               	
+ 121               	#include <avr/io.h>
+   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
+   2               	   Copyright (c) 2007 Eric B. Weddington
+   3               	   All rights reserved.
+   4               	
+   5               	   Redistribution and use in source and binary forms, with or without
+   6               	   modification, are permitted provided that the following conditions are met:
+   7               	
+   8               	   * Redistributions of source code must retain the above copyright
+   9               	     notice, this list of conditions and the following disclaimer.
+  10               	
+  11               	   * Redistributions in binary form must reproduce the above copyright
+  12               	     notice, this list of conditions and the following disclaimer in
+  13               	     the documentation and/or other materials provided with the
+  14               	     distribution.
+  15               	
+  16               	   * Neither the name of the copyright holders nor the names of
+  17               	     contributors may be used to endorse or promote products derived
+  18               	     from this software without specific prior written permission.
+  19               	
+  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  30               	  POSSIBILITY OF SUCH DAMAGE. */
+  31               	
+  32               	/* $Id: io.h,v 1.52.2.28 2009/12/20 17:02:53 arcanum Exp $ */
+  33               	
+  34               	/** \file */
+  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
+  36               	    \code #include <avr/io.h> \endcode
+  37               	
+  38               	    This header file includes the apropriate IO definitions for the
+  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
+  40               	    command-line switch.  This is done by diverting to the appropriate
+  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
+  42               	    never be included directly.  Some register names common to all
+  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
+  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
+  45               	    but most of the details come from the respective include file.
+  46               	
+  47               	    Note that this file always includes the following files:
+  48               	    \code 
+  49               	    #include <avr/sfr_defs.h>
+  50               	    #include <avr/portpins.h>
+  51               	    #include <avr/common.h>
+  52               	    #include <avr/version.h>
+  53               	    \endcode
+  54               	    See \ref avr_sfr for more details about that header file.
+  55               	
+  56               	    Included are definitions of the IO register set and their
+  57               	    respective bit values as specified in the Atmel documentation.
+  58               	    Note that inconsistencies in naming conventions,
+  59               	    so even identical functions sometimes get different names on
+  60               	    different devices.
+  61               	
+  62               	    Also included are the specific names useable for interrupt
+  63               	    function definitions as documented
+  64               	    \ref avr_signames "here".
+  65               	
+  66               	    Finally, the following macros are defined:
+  67               	
+  68               	    - \b RAMEND
+  69               	    <br>
+  70               	    The last on-chip RAM address.
+  71               	    <br>
+  72               	    - \b XRAMEND
+  73               	    <br>
+  74               	    The last possible RAM location that is addressable. This is equal to 
+  75               	    RAMEND for devices that do not allow for external RAM. For devices 
+  76               	    that allow external RAM, this will be larger than RAMEND.
+  77               	    <br>
+  78               	    - \b E2END
+  79               	    <br>
+  80               	    The last EEPROM address.
+  81               	    <br>
+  82               	    - \b FLASHEND
+  83               	    <br>
+  84               	    The last byte address in the Flash program space.
+  85               	    <br>
+  86               	    - \b SPM_PAGESIZE
+  87               	    <br>
+  88               	    For devices with bootloader support, the flash pagesize
+  89               	    (in bytes) to be used for the \c SPM instruction. 
+  90               	    - \b E2PAGESIZE
+  91               	    <br>
+  92               	    The size of the EEPROM page.
+  93               	    
+  94               	*/
+  95               	
+  96               	#ifndef _AVR_IO_H_
+  97               	#define _AVR_IO_H_
+  98               	
+  99               	#include <avr/sfr_defs.h>
+   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
+ 100               	
+ 101               	#if defined (__AVR_AT94K__)
+ 102               	#  include <avr/ioat94k.h>
+ 103               	#elif defined (__AVR_AT43USB320__)
+ 104               	#  include <avr/io43u32x.h>
+ 105               	#elif defined (__AVR_AT43USB355__)
+ 106               	#  include <avr/io43u35x.h>
+ 107               	#elif defined (__AVR_AT76C711__)
+ 108               	#  include <avr/io76c711.h>
+ 109               	#elif defined (__AVR_AT86RF401__)
+ 110               	#  include <avr/io86r401.h>
+ 111               	#elif defined (__AVR_AT90PWM1__)
+ 112               	#  include <avr/io90pwm1.h>
+ 113               	#elif defined (__AVR_AT90PWM2__)
+ 114               	#  include <avr/io90pwmx.h>
+ 115               	#elif defined (__AVR_AT90PWM2B__)
+ 116               	#  include <avr/io90pwm2b.h>
+ 117               	#elif defined (__AVR_AT90PWM3__)
+ 118               	#  include <avr/io90pwmx.h>
+ 119               	#elif defined (__AVR_AT90PWM3B__)
+ 120               	#  include <avr/io90pwm3b.h>
+ 121               	#elif defined (__AVR_AT90PWM216__)
+ 122               	#  include <avr/io90pwm216.h>
+ 123               	#elif defined (__AVR_AT90PWM316__)
+ 124               	#  include <avr/io90pwm316.h>
+ 125               	#elif defined (__AVR_AT90PWM81__)
+ 126               	#  include <avr/io90pwm81.h>
+ 127               	#elif defined (__AVR_ATmega8U2__)
+ 128               	#  include <avr/iom8u2.h>
+ 129               	#elif defined (__AVR_ATmega16M1__)
+ 130               	#  include <avr/iom16m1.h>
+ 131               	#elif defined (__AVR_ATmega16U2__)
+ 132               	#  include <avr/iom16u2.h>
+ 133               	#elif defined (__AVR_ATmega16U4__)
+ 134               	#  include <avr/iom16u4.h>
+ 135               	#elif defined (__AVR_ATmega32C1__)
+ 136               	#  include <avr/iom32c1.h>
+ 137               	#elif defined (__AVR_ATmega32M1__)
+ 138               	#  include <avr/iom32m1.h>
+ 139               	#elif defined (__AVR_ATmega32U2__)
+ 140               	#  include <avr/iom32u2.h>
+ 141               	#elif defined (__AVR_ATmega32U4__)
+ 142               	#  include <avr/iom32u4.h>
+ 143               	#elif defined (__AVR_ATmega32U6__)
+ 144               	#  include <avr/iom32u6.h>
+ 145               	#elif defined (__AVR_ATmega64C1__)
+ 146               	#  include <avr/iom64c1.h>
+ 147               	#elif defined (__AVR_ATmega64M1__)
+ 148               	#  include <avr/iom64m1.h>
+ 149               	#elif defined (__AVR_ATmega128__)
+ 150               	#  include <avr/iom128.h>
+ 151               	#elif defined (__AVR_ATmega1280__)
+ 152               	#  include <avr/iom1280.h>
+ 153               	#elif defined (__AVR_ATmega1281__)
+ 154               	#  include <avr/iom1281.h>
+ 155               	#elif defined (__AVR_ATmega1284P__)
+ 156               	#  include <avr/iom1284p.h>
+ 157               	#elif defined (__AVR_ATmega128RFA1__)
+ 158               	#  include <avr/iom128rfa1.h>
+ 159               	#elif defined (__AVR_ATmega2560__)
+ 160               	#  include <avr/iom2560.h>
+ 161               	#elif defined (__AVR_ATmega2561__)
+ 162               	#  include <avr/iom2561.h>
+ 163               	#elif defined (__AVR_AT90CAN32__)
+ 164               	#  include <avr/iocan32.h>
+ 165               	#elif defined (__AVR_AT90CAN64__)
+ 166               	#  include <avr/iocan64.h>
+ 167               	#elif defined (__AVR_AT90CAN128__)
+ 168               	#  include <avr/iocan128.h>
+ 169               	#elif defined (__AVR_AT90USB82__)
+ 170               	#  include <avr/iousb82.h>
+ 171               	#elif defined (__AVR_AT90USB162__)
+ 172               	#  include <avr/iousb162.h>
+ 173               	#elif defined (__AVR_AT90USB646__)
+ 174               	#  include <avr/iousb646.h>
+ 175               	#elif defined (__AVR_AT90USB647__)
+ 176               	#  include <avr/iousb647.h>
+ 177               	#elif defined (__AVR_AT90USB1286__)
+ 178               	#  include <avr/iousb1286.h>
+ 179               	#elif defined (__AVR_AT90USB1287__)
+ 180               	#  include <avr/iousb1287.h>
+ 181               	#elif defined (__AVR_ATmega64__)
+ 182               	#  include <avr/iom64.h>
+ 183               	#elif defined (__AVR_ATmega640__)
+ 184               	#  include <avr/iom640.h>
+ 185               	#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
+ 186               	#  include <avr/iom644.h>
+ 187               	#elif defined (__AVR_ATmega644P__)
+ 188               	#  include <avr/iom644p.h>
+ 189               	#elif defined (__AVR_ATmega644PA__)
+ 190               	#  include <avr/iom644pa.h>
+ 191               	#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
+ 192               	#  include <avr/iom645.h>
+ 193               	#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__
+ 194               	#  include <avr/iom6450.h>
+ 195               	#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
+ 196               	#  include <avr/iom649.h>
+ 197               	#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__
+ 198               	#  include <avr/iom6490.h>
+ 199               	#elif defined (__AVR_ATmega649P__)
+ 200               	#  include <avr/iom649p.h>
+ 201               	#elif defined (__AVR_ATmega64HVE__)
+ 202               	#  include <avr/iom64hve.h>
+ 203               	#elif defined (__AVR_ATmega103__)
+ 204               	#  include <avr/iom103.h>
+ 205               	#elif defined (__AVR_ATmega32__)
+ 206               	#  include <avr/iom32.h>
+ 207               	#elif defined (__AVR_ATmega323__)
+ 208               	#  include <avr/iom323.h>
+ 209               	#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
+ 210               	#  include <avr/iom324.h>
+ 211               	#elif defined (__AVR_ATmega324PA__)
+ 212               	#  include <avr/iom324pa.h>
+ 213               	#elif defined (__AVR_ATmega325__)
+ 214               	#  include <avr/iom325.h>
+ 215               	#elif defined (__AVR_ATmega325P__)
+ 216               	#  include <avr/iom325.h>
+ 217               	#elif defined (__AVR_ATmega3250__)
+ 218               	#  include <avr/iom3250.h>
+ 219               	#elif defined (__AVR_ATmega3250P__)
+ 220               	#  include <avr/iom3250.h>
+ 221               	#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
+ 222               	#  include <avr/iom328p.h>
+   1               	/* Copyright (c) 2007 Atmel Corporation
+ 223               	#elif defined (__AVR_ATmega329__)
+ 224               	#  include <avr/iom329.h>
+ 225               	#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
+ 226               	#  include <avr/iom329.h>
+ 227               	#elif defined (__AVR_ATmega3290__)
+ 228               	#  include <avr/iom3290.h>
+ 229               	#elif defined (__AVR_ATmega3290P__)
+ 230               	#  include <avr/iom3290.h>
+ 231               	#elif defined (__AVR_ATmega32HVB__)
+ 232               	#  include <avr/iom32hvb.h>
+ 233               	#elif defined (__AVR_ATmega406__)
+ 234               	#  include <avr/iom406.h>
+ 235               	#elif defined (__AVR_ATmega16__)
+ 236               	#  include <avr/iom16.h>
+ 237               	#elif defined (__AVR_ATmega16A__)
+ 238               	#  include <avr/iom16a.h>
+ 239               	#elif defined (__AVR_ATmega161__)
+ 240               	#  include <avr/iom161.h>
+ 241               	#elif defined (__AVR_ATmega162__)
+ 242               	#  include <avr/iom162.h>
+ 243               	#elif defined (__AVR_ATmega163__)
+ 244               	#  include <avr/iom163.h>
+ 245               	#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
+ 246               	#  include <avr/iom164.h>
+ 247               	#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
+ 248               	#  include <avr/iom165.h>
+ 249               	#elif defined (__AVR_ATmega165P__)
+ 250               	#  include <avr/iom165p.h>
+ 251               	#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
+ 252               	#  include <avr/iom168.h>
+ 253               	#elif defined (__AVR_ATmega168P__)
+ 254               	#  include <avr/iom168p.h>
+ 255               	#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
+ 256               	#  include <avr/iom169.h>
+ 257               	#elif defined (__AVR_ATmega169P__)
+ 258               	#  include <avr/iom169p.h>
+ 259               	#elif defined (__AVR_ATmega169PA__)
+ 260               	#  include <avr/iom169pa.h>
+ 261               	#elif defined (__AVR_ATmega8HVA__)
+ 262               	#  include <avr/iom8hva.h>
+ 263               	#elif defined (__AVR_ATmega16HVA__)
+ 264               	#  include <avr/iom16hva.h>
+ 265               	#elif defined (__AVR_ATmega16HVA2__)
+ 266               	#  include <avr/iom16hva2.h>
+ 267               	#elif defined (__AVR_ATmega16HVB__)
+ 268               	#  include <avr/iom16hvb.h>
+ 269               	#elif defined (__AVR_ATmega8__)
+ 270               	#  include <avr/iom8.h>
+ 271               	#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
+ 272               	#  include <avr/iom48.h>
+ 273               	#elif defined (__AVR_ATmega48P__)
+ 274               	#  include <avr/iom48p.h>
+ 275               	#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmega88A__)
+ 276               	#  include <avr/iom88.h>
+ 277               	#elif defined (__AVR_ATmega88P__)
+ 278               	#  include <avr/iom88p.h>
+ 279               	#elif defined (__AVR_ATmega88PA__)
+ 280               	#  include <avr/iom88pa.h>
+ 281               	#elif defined (__AVR_ATmega8515__)
+ 282               	#  include <avr/iom8515.h>
+ 283               	#elif defined (__AVR_ATmega8535__)
+ 284               	#  include <avr/iom8535.h>
+ 285               	#elif defined (__AVR_AT90S8535__)
+ 286               	#  include <avr/io8535.h>
+ 287               	#elif defined (__AVR_AT90C8534__)
+ 288               	#  include <avr/io8534.h>
+ 289               	#elif defined (__AVR_AT90S8515__)
+ 290               	#  include <avr/io8515.h>
+ 291               	#elif defined (__AVR_AT90S4434__)
+ 292               	#  include <avr/io4434.h>
+ 293               	#elif defined (__AVR_AT90S4433__)
+ 294               	#  include <avr/io4433.h>
+ 295               	#elif defined (__AVR_AT90S4414__)
+ 296               	#  include <avr/io4414.h>
+ 297               	#elif defined (__AVR_ATtiny22__)
+ 298               	#  include <avr/iotn22.h>
+ 299               	#elif defined (__AVR_ATtiny26__)
+ 300               	#  include <avr/iotn26.h>
+ 301               	#elif defined (__AVR_AT90S2343__)
+ 302               	#  include <avr/io2343.h>
+ 303               	#elif defined (__AVR_AT90S2333__)
+ 304               	#  include <avr/io2333.h>
+ 305               	#elif defined (__AVR_AT90S2323__)
+ 306               	#  include <avr/io2323.h>
+ 307               	#elif defined (__AVR_AT90S2313__)
+ 308               	#  include <avr/io2313.h>
+ 309               	#elif defined (__AVR_ATtiny2313__)
+ 310               	#  include <avr/iotn2313.h>
+ 311               	#elif defined (__AVR_ATtiny2313A__)
+ 312               	#  include <avr/iotn2313a.h>
+ 313               	#elif defined (__AVR_ATtiny13__)
+ 314               	#  include <avr/iotn13.h>
+ 315               	#elif defined (__AVR_ATtiny13A__)
+ 316               	#  include <avr/iotn13a.h>
+ 317               	#elif defined (__AVR_ATtiny25__)
+ 318               	#  include <avr/iotn25.h>
+ 319               	#elif defined (__AVR_ATtiny4313__)
+ 320               	#  include <avr/iotn4313.h>
+ 321               	#elif defined (__AVR_ATtiny45__)
+ 322               	#  include <avr/iotn45.h>
+ 323               	#elif defined (__AVR_ATtiny85__)
+ 324               	#  include <avr/iotn85.h>
+ 325               	#elif defined (__AVR_ATtiny24__)
+ 326               	#  include <avr/iotn24.h>
+ 327               	#elif defined (__AVR_ATtiny24A__)
+ 328               	#  include <avr/iotn24a.h>
+ 329               	#elif defined (__AVR_ATtiny44__)
+ 330               	#  include <avr/iotn44.h>
+ 331               	#elif defined (__AVR_ATtiny44A__)
+ 332               	#  include <avr/iotn44a.h>
+ 333               	#elif defined (__AVR_ATtiny84__)
+ 334               	#  include <avr/iotn84.h>
+ 335               	#elif defined (__AVR_ATtiny261__)
+ 336               	#  include <avr/iotn261.h>
+ 337               	#elif defined (__AVR_ATtiny261A__)
+ 338               	#  include <avr/iotn261a.h>
+ 339               	#elif defined (__AVR_ATtiny461__)
+ 340               	#  include <avr/iotn461.h>
+ 341               	#elif defined (__AVR_ATtiny461A__)
+ 342               	#  include <avr/iotn461a.h>
+ 343               	#elif defined (__AVR_ATtiny861__)
+ 344               	#  include <avr/iotn861.h>
+ 345               	#elif defined (__AVR_ATtiny861A__)
+ 346               	#  include <avr/iotn861a.h>
+ 347               	#elif defined (__AVR_ATtiny43U__)
+ 348               	#  include <avr/iotn43u.h>
+ 349               	#elif defined (__AVR_ATtiny48__)
+ 350               	#  include <avr/iotn48.h>
+ 351               	#elif defined (__AVR_ATtiny88__)
+ 352               	#  include <avr/iotn88.h>
+ 353               	#elif defined (__AVR_ATtiny87__)
+ 354               	#  include <avr/iotn87.h>
+ 355               	#elif defined (__AVR_ATtiny167__)
+ 356               	#  include <avr/iotn167.h>
+ 357               	#elif defined (__AVR_AT90SCR100__)
+ 358               	#  include <avr/io90scr100.h>
+ 359               	#elif defined (__AVR_ATxmega16A4__)
+ 360               	#  include <avr/iox16a4.h>
+ 361               	#elif defined (__AVR_ATxmega16D4__)
+ 362               	#  include <avr/iox16d4.h>
+ 363               	#elif defined (__AVR_ATxmega32A4__)
+ 364               	#  include <avr/iox32a4.h>
+ 365               	#elif defined (__AVR_ATxmega32D4__)
+ 366               	#  include <avr/iox32d4.h>
+ 367               	#elif defined (__AVR_ATxmega64A1__)
+ 368               	#  include <avr/iox64a1.h>
+ 369               	#elif defined (__AVR_ATxmega64A3__)
+ 370               	#  include <avr/iox64a3.h>
+ 371               	#elif defined (__AVR_ATxmega64D3__)
+ 372               	#  include <avr/iox64d3.h>
+ 373               	#elif defined (__AVR_ATxmega128A1__)
+ 374               	#  include <avr/iox128a1.h>
+ 375               	#elif defined (__AVR_ATxmega128A3__)
+ 376               	#  include <avr/iox128a3.h>
+ 377               	#elif defined (__AVR_ATxmega128D3__)
+ 378               	#  include <avr/iox128d3.h>
+ 379               	#elif defined (__AVR_ATxmega192A3__)
+ 380               	#  include <avr/iox192a3.h>
+ 381               	#elif defined (__AVR_ATxmega192D3__)
+ 382               	#  include <avr/iox192d3.h>
+ 383               	#elif defined (__AVR_ATxmega256A3__)
+ 384               	#  include <avr/iox256a3.h>
+ 385               	#elif defined (__AVR_ATxmega256A3B__)
+ 386               	#  include <avr/iox256a3b.h>
+ 387               	#elif defined (__AVR_ATxmega256D3__)
+ 388               	#  include <avr/iox256d3.h>
+ 389               	#elif defined (__AVR_ATA6289__)
+ 390               	#  include <avr/ioa6289.h>
+ 391               	/* avr1: the following only supported for assembler programs */
+ 392               	#elif defined (__AVR_ATtiny28__)
+ 393               	#  include <avr/iotn28.h>
+ 394               	#elif defined (__AVR_AT90S1200__)
+ 395               	#  include <avr/io1200.h>
+ 396               	#elif defined (__AVR_ATtiny15__)
+ 397               	#  include <avr/iotn15.h>
+ 398               	#elif defined (__AVR_ATtiny12__)
+ 399               	#  include <avr/iotn12.h>
+ 400               	#elif defined (__AVR_ATtiny11__)
+ 401               	#  include <avr/iotn11.h>
+ 402               	#else
+ 403               	#  if !defined(__COMPILING_AVR_LIBC__)
+ 404               	#    warning "device type not defined"
+ 405               	#  endif
+ 406               	#endif
+ 407               	
+ 408               	#include <avr/portpins.h>
+   1               	/* Copyright (c) 2003  Theodore A. Roth
+ 409               	
+ 410               	#include <avr/common.h>
+   1               	/* Copyright (c) 2007 Eric B. Weddington
+ 411               	
+ 412               	#include <avr/version.h>
+   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
+ 413               	
+ 414               	/* Include fuse.h after individual IO header files. */
+ 415               	#include <avr/fuse.h>
+   1               	/* Copyright (c) 2007, Atmel Corporation
+ 416               	
+ 417               	/* Include lock.h after individual IO header files. */
+ 418               	#include <avr/lock.h>
+   1               	/* Copyright (c) 2007, Atmel Corporation
+ 419               	
+ 122               	#ifdef __ASSEMBLER__
+  20               	#include "usbdrv.h"         /* for common defs */
+   1               	/* Name: usbdrv.h
+   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+   3               	 * Author: Christian Starkjohann
+   4               	 * Creation Date: 2004-12-29
+   5               	 * Tabsize: 4
+   6               	 * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+   8               	 * This Revision: $Id: usbdrv.h 793 2010-07-15 15:58:11Z cs $
+   9               	 */
+  10               	
+  11               	#ifndef __usbdrv_h_included__
+  12               	#define __usbdrv_h_included__
+  13               	#include "usbconfig.h"
+   1               	/* Name: usbconfig.h
+  14               	#include "usbportability.h"
+  21               	
+  22               	/* register names */
+  23               	#define x1      r16
+  24               	#define x2      r17
+  25               	#define shift   r18
+  26               	#define cnt     r19
+  27               	#define x3      r20
+  28               	#define x4      r21
+  29               	#define x5		r22
+  30               	#define bitcnt  x5
+  31               	#define phase   x4
+  32               	#define leap    x4
+  33               	
+  34               	/* Some assembler dependent definitions and declarations: */
+  35               	
+  36               	#ifdef __IAR_SYSTEMS_ASM__
+  37               	    extern  usbRxBuf, usbDeviceAddr, usbNewDeviceAddr, usbInputBufOffset
+  38               	    extern  usbCurrentTok, usbRxLen, usbRxToken, usbTxLen
+  39               	    extern  usbTxBuf, usbTxStatus1, usbTxStatus3
+  40               	#   if USB_COUNT_SOF
+  41               	        extern usbSofCount
+  42               	#   endif
+  43               	    public  usbCrc16
+  44               	    public  usbCrc16Append
+  45               	
+  46               	    COMMON  INTVEC
+  47               	#   ifndef USB_INTR_VECTOR
+  48               	        ORG     INT0_vect
+  49               	#   else /* USB_INTR_VECTOR */
+  50               	        ORG     USB_INTR_VECTOR
+  51               	#       undef   USB_INTR_VECTOR
+  52               	#   endif /* USB_INTR_VECTOR */
+  53               	#   define  USB_INTR_VECTOR usbInterruptHandler
+  54               	    rjmp    USB_INTR_VECTOR
+  55               	    RSEG    CODE
+  56               	
+  57               	#else /* __IAR_SYSTEMS_ASM__ */
+  58               	
+  59               	#   ifndef USB_INTR_VECTOR /* default to hardware interrupt INT0 */
+  60               	#       ifdef INT0_vect
+  61               	#           define USB_INTR_VECTOR  INT0_vect       // this is the "new" define for the vector
+  62               	#       else
+  63               	#           define USB_INTR_VECTOR  SIG_INTERRUPT0  // this is the "old" vector
+  64               	#       endif
+  65               	#   endif
+  66               	    .text
+  67               	    .global USB_INTR_VECTOR
+  69               	    .global usbCrc16
+  70               	    .global usbCrc16Append
+  71               	#endif /* __IAR_SYSTEMS_ASM__ */
+  72               	
+  73               	
+  74               	#if USB_INTR_PENDING < 0x40 /* This is an I/O address, use in and out */
+  75               	#   define  USB_LOAD_PENDING(reg)   in reg, USB_INTR_PENDING
+  76               	#   define  USB_STORE_PENDING(reg)  out USB_INTR_PENDING, reg
+  77               	#else   /* It's a memory address, use lds and sts */
+  78               	#   define  USB_LOAD_PENDING(reg)   lds reg, USB_INTR_PENDING
+  79               	#   define  USB_STORE_PENDING(reg)  sts USB_INTR_PENDING, reg
+  80               	#endif
+  81               	
+  82               	#define usbTxLen1   usbTxStatus1
+  83               	#define usbTxBuf1   (usbTxStatus1 + 1)
+  84               	#define usbTxLen3   usbTxStatus3
+  85               	#define usbTxBuf3   (usbTxStatus3 + 1)
+  86               	
+  87               	
+  88               	;----------------------------------------------------------------------------
+  89               	; Utility functions
+  90               	;----------------------------------------------------------------------------
+  91               	
+  92               	#ifdef __IAR_SYSTEMS_ASM__
+  93               	/* Register assignments for usbCrc16 on IAR cc */
+  94               	/* Calling conventions on IAR:
+  95               	 * First parameter passed in r16/r17, second in r18/r19 and so on.
+  96               	 * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+  97               	 * Result is passed in r16/r17
+  98               	 * In case of the "tiny" memory model, pointers are only 8 bit with no
+  99               	 * padding. We therefore pass argument 1 as "16 bit unsigned".
+ 100               	 */
+ 101               	RTMODEL "__rt_version", "3"
+ 102               	/* The line above will generate an error if cc calling conventions change.
+ 103               	 * The value "3" above is valid for IAR 4.10B/W32
+ 104               	 */
+ 105               	#   define argLen   r18 /* argument 2 */
+ 106               	#   define argPtrL  r16 /* argument 1 */
+ 107               	#   define argPtrH  r17 /* argument 1 */
+ 108               	
+ 109               	#   define resCrcL  r16 /* result */
+ 110               	#   define resCrcH  r17 /* result */
+ 111               	
+ 112               	#   define ptrL     ZL
+ 113               	#   define ptrH     ZH
+ 114               	#   define ptr      Z
+ 115               	#   define byte     r22
+ 116               	#   define bitCnt   r19
+ 117               	#   define polyL    r20
+ 118               	#   define polyH    r21
+ 119               	#   define scratch  r23
+ 120               	
+ 121               	#else  /* __IAR_SYSTEMS_ASM__ */ 
+ 122               	/* Register assignments for usbCrc16 on gcc */
+ 123               	/* Calling conventions on gcc:
+ 124               	 * First parameter passed in r24/r25, second in r22/23 and so on.
+ 125               	 * Callee must preserve r1-r17, r28/r29
+ 126               	 * Result is passed in r24/r25
+ 127               	 */
+ 128               	#   define argLen   r22 /* argument 2 */
+ 129               	#   define argPtrL  r24 /* argument 1 */
+ 130               	#   define argPtrH  r25 /* argument 1 */
+ 131               	
+ 132               	#   define resCrcL  r24 /* result */
+ 133               	#   define resCrcH  r25 /* result */
+ 134               	
+ 135               	#   define ptrL     XL
+ 136               	#   define ptrH     XH
+ 137               	#   define ptr      x
+ 138               	#   define byte     r18
+ 139               	#   define bitCnt   r19
+ 140               	#   define polyL    r20
+ 141               	#   define polyH    r21
+ 142               	#   define scratch  r23
+ 143               	
+ 144               	#endif
+ 145               	
+ 146               	#if USB_USE_FAST_CRC
+ 147               	
+ 148               	; This implementation is faster, but has bigger code size
+ 149               	; Thanks to Slawomir Fras (BoskiDialer) for this code!
+ 150               	; It implements the following C pseudo-code:
+ 151               	; unsigned table(unsigned char x)
+ 152               	; {
+ 153               	; unsigned    value;
+ 154               	; 
+ 155               	;     value = (unsigned)x << 6;
+ 156               	;     value ^= (unsigned)x << 7;
+ 157               	;     if(parity(x))
+ 158               	;         value ^= 0xc001;
+ 159               	;     return value;
+ 160               	; }
+ 161               	; unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen)
+ 162               	; {
+ 163               	; unsigned crc = 0xffff;
+ 164               	; 
+ 165               	;     while(argLen--)
+ 166               	;         crc = table(lo8(crc) ^ *argPtr++) ^ hi8(crc);
+ 167               	;     return ~crc;
+ 168               	; }
+ 169               	
+ 170               	; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+ 171               	;   argPtr  r24+25 / r16+r17
+ 172               	;   argLen  r22 / r18
+ 173               	; temp variables:
+ 174               	;   byte    r18 / r22
+ 175               	;   scratch r23
+ 176               	;   resCrc  r24+r25 / r16+r17
+ 177               	;   ptr     X / Z
+ 178               	usbCrc16:
+ 179               	    mov     ptrL, argPtrL
+ 180               	    mov     ptrH, argPtrH
+ 181               	    ldi     resCrcL, 0xFF
+ 182               	    ldi     resCrcH, 0xFF
+ 183               	    rjmp    usbCrc16LoopTest
+ 184               	usbCrc16ByteLoop:
+ 185               	    ld      byte, ptr+
+ 186               	    eor     resCrcL, byte   ; resCrcL is now 'x' in table()
+ 187               	    mov     byte, resCrcL   ; compute parity of 'x'
+ 188               	    swap    byte
+ 189               	    eor     byte, resCrcL
+ 190               	    mov     scratch, byte
+ 191               	    lsr     byte
+ 192               	    lsr     byte
+ 193               	    eor     byte, scratch
+ 194               	    inc     byte
+ 195               	    lsr     byte
+ 196               	    andi    byte, 1         ; byte is now parity(x)
+ 197               	    mov     scratch, resCrcL
+ 198               	    mov     resCrcL, resCrcH
+ 199               	    eor     resCrcL, byte   ; low byte of if(parity(x)) value ^= 0xc001;
+ 200               	    neg     byte
+ 201               	    andi    byte, 0xc0
+ 202               	    mov     resCrcH, byte   ; high byte of if(parity(x)) value ^= 0xc001;
+ 203               	    clr     byte
+ 204               	    lsr     scratch
+ 205               	    ror     byte
+ 206               	    eor     resCrcH, scratch
+ 207               	    eor     resCrcL, byte
+ 208               	    lsr     scratch
+ 209               	    ror     byte
+ 210               	    eor     resCrcH, scratch
+ 211               	    eor     resCrcL, byte
+ 212               	usbCrc16LoopTest:
+ 213               	    subi    argLen, 1
+ 214               	    brsh    usbCrc16ByteLoop
+ 215               	    com     resCrcL
+ 216               	    com     resCrcH
+ 217               	    ret
+ 218               	
+ 219               	#else   /* USB_USE_FAST_CRC */
+ 220               	
+ 221               	; This implementation is slower, but has less code size
+ 222               	;
+ 223               	; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+ 224               	;   argPtr  r24+25 / r16+r17
+ 225               	;   argLen  r22 / r18
+ 226               	; temp variables:
+ 227               	;   byte    r18 / r22
+ 228               	;   bitCnt  r19
+ 229               	;   poly    r20+r21
+ 230               	;   scratch r23
+ 231               	;   resCrc  r24+r25 / r16+r17
+ 232               	;   ptr     X / Z
+ 233               	usbCrc16:
+ 234:usbdrv/usbdrvasm.S ****     mov     ptrL, argPtrL
+ 235:usbdrv/usbdrvasm.S ****     mov     ptrH, argPtrH
+ 236:usbdrv/usbdrvasm.S ****     ldi     resCrcL, 0
+ 237:usbdrv/usbdrvasm.S ****     ldi     resCrcH, 0
+ 238:usbdrv/usbdrvasm.S ****     ldi     polyL, lo8(0xa001)
+ 239:usbdrv/usbdrvasm.S ****     ldi     polyH, hi8(0xa001)
+ 240:usbdrv/usbdrvasm.S ****     com     argLen      ; argLen = -argLen - 1: modified loop to ensure that carry is set
+ 241:usbdrv/usbdrvasm.S ****     ldi     bitCnt, 0   ; loop counter with starnd condition = end condition
+ 242:usbdrv/usbdrvasm.S ****     rjmp    usbCrcLoopEntry
+ 243               	usbCrcByteLoop:
+ 244:usbdrv/usbdrvasm.S ****     ld      byte, ptr+
+ 245:usbdrv/usbdrvasm.S ****     eor     resCrcL, byte
+ 246               	usbCrcBitLoop:
+ 247:usbdrv/usbdrvasm.S ****     ror     resCrcH     ; carry is always set here (see brcs jumps to here)
+ 248:usbdrv/usbdrvasm.S ****     ror     resCrcL
+ 249:usbdrv/usbdrvasm.S ****     brcs    usbCrcNoXor
+ 250:usbdrv/usbdrvasm.S ****     eor     resCrcL, polyL
+ 251:usbdrv/usbdrvasm.S ****     eor     resCrcH, polyH
+ 252               	usbCrcNoXor:
+ 253:usbdrv/usbdrvasm.S ****     subi    bitCnt, 224 ; (8 * 224) % 256 = 0; this loop iterates 8 times
+ 254:usbdrv/usbdrvasm.S ****     brcs    usbCrcBitLoop
+ 255               	usbCrcLoopEntry:
+ 256:usbdrv/usbdrvasm.S ****     subi    argLen, -1
+ 257:usbdrv/usbdrvasm.S ****     brcs    usbCrcByteLoop
+ 258               	usbCrcReady:
+ 259:usbdrv/usbdrvasm.S ****     ret
+ 260               	; Thanks to Reimar Doeffinger for optimizing this CRC routine!
+ 261               	
+ 262               	#endif /* USB_USE_FAST_CRC */
+ 263               	
+ 264               	; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
+ 265               	usbCrc16Append:
+ 266:usbdrv/usbdrvasm.S ****     rcall   usbCrc16
+ 267:usbdrv/usbdrvasm.S ****     st      ptr+, resCrcL
+ 268:usbdrv/usbdrvasm.S ****     st      ptr+, resCrcH
+ 269:usbdrv/usbdrvasm.S ****     ret
+ 270               	
+ 271               	#undef argLen
+ 272               	#undef argPtrL
+ 273               	#undef argPtrH
+ 274               	#undef resCrcL
+ 275               	#undef resCrcH
+ 276               	#undef ptrL
+ 277               	#undef ptrH
+ 278               	#undef ptr
+ 279               	#undef byte
+ 280               	#undef bitCnt
+ 281               	#undef polyL
+ 282               	#undef polyH
+ 283               	#undef scratch
+ 284               	
+ 285               	
+ 286               	#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+ 287               	#ifdef __IAR_SYSTEMS_ASM__
+ 288               	/* Register assignments for usbMeasureFrameLength on IAR cc */
+ 289               	/* Calling conventions on IAR:
+ 290               	 * First parameter passed in r16/r17, second in r18/r19 and so on.
+ 291               	 * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ 292               	 * Result is passed in r16/r17
+ 293               	 * In case of the "tiny" memory model, pointers are only 8 bit with no
+ 294               	 * padding. We therefore pass argument 1 as "16 bit unsigned".
+ 295               	 */
+ 296               	#   define resL     r16
+ 297               	#   define resH     r17
+ 298               	#   define cnt16L   r30
+ 299               	#   define cnt16H   r31
+ 300               	#   define cntH     r18
+ 301               	
+ 302               	#else  /* __IAR_SYSTEMS_ASM__ */ 
+ 303               	/* Register assignments for usbMeasureFrameLength on gcc */
+ 304               	/* Calling conventions on gcc:
+ 305               	 * First parameter passed in r24/r25, second in r22/23 and so on.
+ 306               	 * Callee must preserve r1-r17, r28/r29
+ 307               	 * Result is passed in r24/r25
+ 308               	 */
+ 309               	#   define resL     r24
+ 310               	#   define resH     r25
+ 311               	#   define cnt16L   r24
+ 312               	#   define cnt16H   r25
+ 313               	#   define cntH     r26
+ 314               	#endif
+ 315               	#   define cnt16    cnt16L
+ 316               	
+ 317               	; extern unsigned usbMeasurePacketLength(void);
+ 318               	; returns time between two idle strobes in multiples of 7 CPU clocks
+ 319               	.global usbMeasureFrameLength
+ 320               	usbMeasureFrameLength:
+ 321               	    ldi     cntH, 6         ; wait ~ 10 ms for D- == 0
+ 322               	    clr     cnt16L
+ 323               	    clr     cnt16H
+ 324               	usbMFTime16:
+ 325               	    dec     cntH
+ 326               	    breq    usbMFTimeout
+ 327               	usbMFWaitStrobe:            ; first wait for D- == 0 (idle strobe)
+ 328               	    sbiw    cnt16, 1        ;[0] [6]
+ 329               	    breq    usbMFTime16     ;[2]
+ 330               	    sbic    USBIN, USBMINUS ;[3]
+ 331               	    rjmp    usbMFWaitStrobe ;[4]
+ 332               	usbMFWaitIdle:              ; then wait until idle again
+ 333               	    sbis    USBIN, USBMINUS ;1 wait for D- == 1
+ 334               	    rjmp    usbMFWaitIdle   ;2
+ 335               	    ldi     cnt16L, 1       ;1 represents cycles so far
+ 336               	    clr     cnt16H          ;1
+ 337               	usbMFWaitLoop:
+ 338               	    in      cntH, USBIN     ;[0] [7]
+ 339               	    adiw    cnt16, 1        ;[1]
+ 340               	    breq    usbMFTimeout    ;[3]
+ 341               	    andi    cntH, USBMASK   ;[4]
+ 342               	    brne    usbMFWaitLoop   ;[5]
+ 343               	usbMFTimeout:
+ 344               	#if resL != cnt16L
+ 345               	    mov     resL, cnt16L
+ 346               	    mov     resH, cnt16H
+ 347               	#endif
+ 348               	    ret
+ 349               	
+ 350               	#undef resL
+ 351               	#undef resH
+ 352               	#undef cnt16
+ 353               	#undef cnt16L
+ 354               	#undef cnt16H
+ 355               	#undef cntH
+ 356               	
+ 357               	#endif  /* USB_CFG_HAVE_MEASURE_FRAME_LENGTH */
+ 358               	
+ 359               	;----------------------------------------------------------------------------
+ 360               	; Now include the clock rate specific code
+ 361               	;----------------------------------------------------------------------------
+ 362               	
+ 363               	#ifndef USB_CFG_CLOCK_KHZ
+ 364               	#   ifdef F_CPU
+ 365               	#       define USB_CFG_CLOCK_KHZ (F_CPU/1000)
+ 366               	#error "test " USB_CFG_CLOCK_KHZ
+ 367               	#   else
+ 368               	#       error "USB_CFG_CLOCK_KHZ not defined in usbconfig.h and no F_CPU set!"
+ 369               	#   endif
+ 370               	#endif
+ 371               	
+ 372               	#if USB_CFG_CHECK_CRC   /* separate dispatcher for CRC type modules */
+ 373               	#   if USB_CFG_CLOCK_KHZ == 18000
+ 374               	#       include "usbdrvasm18-crc.inc"
+ 375               	#   else
+ 376               	#       error "USB_CFG_CLOCK_KHZ is not one of the supported crc-rates!"
+ 377               	#   endif
+ 378               	#else   /* USB_CFG_CHECK_CRC */
+ 379               	#   if USB_CFG_CLOCK_KHZ == 12000
+ 380               	#       include "usbdrvasm12.inc"
+ 381               	#   elif USB_CFG_CLOCK_KHZ == 12800
+ 382               	#       include "usbdrvasm128.inc"
+ 383               	#   elif USB_CFG_CLOCK_KHZ == 15000
+ 384               	#       include "usbdrvasm15.inc"
+ 385               	#   elif USB_CFG_CLOCK_KHZ == 16000
+ 386               	#       include "usbdrvasm16.inc"
+ 387               	#   elif USB_CFG_CLOCK_KHZ == 16500
+ 388               	#       include "usbdrvasm165.inc"
+ 389               	#   elif USB_CFG_CLOCK_KHZ == 20000
+ 390               	#       include "usbdrvasm20.inc"
+   1               	/* Name: usbdrvasm20.inc
+   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+   3               	 * Author: Jeroen Benschop
+   4               	 * Based on usbdrvasm16.inc from Christian Starkjohann
+   5               	 * Creation Date: 2008-03-05
+   6               	 * Tabsize: 4
+   7               	 * Copyright: (c) 2008 by Jeroen Benschop and OBJECTIVE DEVELOPMENT Software GmbH
+   8               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+   9               	 * Revision: $Id: usbdrvasm20.inc 740 2009-04-13 18:23:31Z cs $
+  10               	 */
+  11               	
+  12               	/* Do not link this file! Link usbdrvasm.S instead, which includes the
+  13               	 * appropriate implementation!
+  14               	 */
+  15               	
+  16               	/*
+  17               	General Description:
+  18               	This file is the 20 MHz version of the asssembler part of the USB driver. It
+  19               	requires a 20 MHz crystal (not a ceramic resonator and not a calibrated RC
+  20               	oscillator).
+  21               	
+  22               	See usbdrv.h for a description of the entire driver.
+  23               	
+  24               	Since almost all of this code is timing critical, don't change unless you
+  25               	really know what you are doing! Many parts require not only a maximum number
+  26               	of CPU cycles, but even an exact number of cycles!
+  27               	*/
+  28               	
+  29               	#define leap2   x3
+  30               	#ifdef __IAR_SYSTEMS_ASM__
+  31               	#define nextInst    $+2
+  32               	#else
+  33               	#define nextInst    .+0
+  34               	#endif
+  35               	
+  36               	;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+  37               	;nominal frequency: 20 MHz -> 13.333333 cycles per bit, 106.666667 cycles per byte
+  38               	; Numbers in brackets are clocks counted from center of last sync bit
+  39               	; when instruction starts
+  40               	;register use in receive loop:
+  41               	; shift assembles the byte currently being received
+  42               	; x1 holds the D+ and D- line state
+  43               	; x2 holds the previous line state
+  44               	; x4 (leap)  is used to add a leap cycle once every three bytes received
+  45               	; X3 (leap2) is used to add a leap cycle once every three stuff bits received
+  46               	; bitcnt is used to determine when a stuff bit is due
+  47               	; cnt holds the number of bytes left in the receive buffer
+  48               	
+  49               	USB_INTR_VECTOR:
+  50               	;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+  51:usbdrv/usbdrvasm20.inc ****     push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+  52:usbdrv/usbdrvasm20.inc ****     in      YL, SREG            ;[-26]
+  53:usbdrv/usbdrvasm20.inc ****     push    YL                  ;[-25]
+  54:usbdrv/usbdrvasm20.inc ****     push    YH                  ;[-23]
+  55               	;----------------------------------------------------------------------------
+  56               	; Synchronize with sync pattern:
+  57               	;----------------------------------------------------------------------------
+  58               	;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+  59               	;sync up with J to K edge during sync pattern -- use fastest possible loops
+  60               	;The first part waits at most 1 bit long since we must be in sync pattern.
+  61               	;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+  62               	;waitForJ, ensure that this prerequisite is met.
+  63               	waitForJ:
+  64:usbdrv/usbdrvasm20.inc ****     inc     YL
+  65:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
+  66:usbdrv/usbdrvasm20.inc ****     brne    waitForJ        ; just make sure we have ANY timeout
+  67               	waitForK:
+  68               	;The following code results in a sampling window of < 1/4 bit which meets the spec.
+  69:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS     ;[-19]
+  70:usbdrv/usbdrvasm20.inc ****     rjmp    foundK              ;[-18]
+  71:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
+  72:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
+  73:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
+  74:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
+  75:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
+  76:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
+  77:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
+  78:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
+  79:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
+  80:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
+  81:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
+  82:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
+  83:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
+  84:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
+  85:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
+  86:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
+  87               	#if USB_COUNT_SOF
+  88:usbdrv/usbdrvasm20.inc ****     lds     YL, usbSofCount
+  89:usbdrv/usbdrvasm20.inc ****     inc     YL
+  90:usbdrv/usbdrvasm20.inc ****     sts     usbSofCount, YL
+  91:usbdrv/usbdrvasm20.inc **** #endif  /* USB_COUNT_SOF */
+  92:usbdrv/usbdrvasm20.inc **** #ifdef USB_SOF_HOOK
+  93:usbdrv/usbdrvasm20.inc ****     USB_SOF_HOOK
+  94:usbdrv/usbdrvasm20.inc **** #endif
+  95:usbdrv/usbdrvasm20.inc ****     rjmp    sofError
+  96               	foundK:                         ;[-16]
+  97               	;{3, 5} after falling D- edge, average delay: 4 cycles
+  98               	;bit0 should be at 34 for center sampling. Currently at 4 so 30 cylces till bit 0 sample
+  99               	;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+ 100               	;are cycles from center of first sync (double K) bit after the instruction
+ 101:usbdrv/usbdrvasm20.inc ****     push    bitcnt              ;[-16]
+ 102               	;   [---]                       ;[-15]
+ 103:usbdrv/usbdrvasm20.inc ****     lds     YL, usbInputBufOffset;[-14]
+ 104               	;   [---]                       ;[-13]
+ 105:usbdrv/usbdrvasm20.inc ****     clr     YH                  ;[-12]
+ 106:usbdrv/usbdrvasm20.inc ****     subi    YL, lo8(-(usbRxBuf));[-11] [rx loop init]
+ 107:usbdrv/usbdrvasm20.inc ****     sbci    YH, hi8(-(usbRxBuf));[-10] [rx loop init]
+ 108:usbdrv/usbdrvasm20.inc ****     push    shift               ;[-9]
+ 109               	;   [---]                       ;[-8]
+ 110:usbdrv/usbdrvasm20.inc ****     ldi     shift,0x40          ;[-7] set msb to "1" so processing bit7 can be detected
+ 111:usbdrv/usbdrvasm20.inc ****     nop2                        ;[-6]
+ 112               	;   [---]                       ;[-5]
+ 113:usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 5           ;[-4] [rx loop init]
+ 114:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+ 115:usbdrv/usbdrvasm20.inc ****     rjmp    haveTwoBitsK        ;[-2]
+ 116:usbdrv/usbdrvasm20.inc ****     pop     shift               ;[-1] undo the push from before
+ 117:usbdrv/usbdrvasm20.inc ****     pop     bitcnt              ;[1] 
+ 118:usbdrv/usbdrvasm20.inc ****     rjmp    waitForK            ;[3] this was not the end of sync, retry
+ 119               	; The entire loop from waitForK until rjmp waitForK above must not exceed two
+ 120               	; bit times (= 27 cycles).
+ 121               	
+ 122               	;----------------------------------------------------------------------------
+ 123               	; push more registers and initialize values while we sample the first bits:
+ 124               	;----------------------------------------------------------------------------
+ 125               	haveTwoBitsK:
+ 126:usbdrv/usbdrvasm20.inc ****     push    x1                  ;[0]
+ 127:usbdrv/usbdrvasm20.inc ****     push    x2                  ;[2]
+ 128:usbdrv/usbdrvasm20.inc ****     push    x3                  ;[4] (leap2)
+ 129:usbdrv/usbdrvasm20.inc ****     ldi     leap2, 0x55         ;[6] add leap cycle on 2nd,5th,8th,... stuff bit
+ 130:usbdrv/usbdrvasm20.inc ****     push    x4                  ;[7] == leap
+ 131:usbdrv/usbdrvasm20.inc ****     ldi     leap, 0x55          ;[9] skip leap cycle on 2nd,5th,8th,... byte received
+ 132:usbdrv/usbdrvasm20.inc ****     push    cnt                 ;[10]
+ 133:usbdrv/usbdrvasm20.inc ****     ldi     cnt, USB_BUFSIZE    ;[12] [rx loop init]
+ 134:usbdrv/usbdrvasm20.inc ****     ldi     x2, 1<<USBPLUS      ;[13] current line state is K state. D+=="1", D-=="0"
+ 135               	bit0:       
+ 136:usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;[0] sample line state
+ 137:usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+ 138:usbdrv/usbdrvasm20.inc ****     rjmp    handleBit           ;[2] make bit0 14 cycles long
+ 139               	
+ 140               	;----------------------------------------------------------------------------
+ 141               	; Process bit7. However, bit 6 still may need unstuffing.
+ 142               	;----------------------------------------------------------------------------
+ 143               	
+ 144               	b6checkUnstuff:
+ 145:usbdrv/usbdrvasm20.inc ****     dec     bitcnt              ;[9]
+ 146:usbdrv/usbdrvasm20.inc ****     breq    unstuff6            ;[10]
+ 147               	bit7:
+ 148:usbdrv/usbdrvasm20.inc ****     subi    cnt, 1              ;[11] cannot use dec becaus it does not affect the carry flag
+ 149:usbdrv/usbdrvasm20.inc ****     brcs    overflow            ;[12] Too many bytes received. Ignore packet
+ 150:usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;[0] sample line state
+ 151:usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+ 152:usbdrv/usbdrvasm20.inc ****     cpse    x1, x2              ;[2] when previous line state equals current line state, handle "1"
+ 153:usbdrv/usbdrvasm20.inc ****     rjmp    b7handle0           ;[3] when line state differs, handle "0"
+ 154:usbdrv/usbdrvasm20.inc ****     sec                         ;[4]
+ 155:usbdrv/usbdrvasm20.inc ****     ror     shift               ;[5] shift "1" into the data
+ 156:usbdrv/usbdrvasm20.inc ****     st      y+, shift           ;[6] store the data into the buffer
+ 157:usbdrv/usbdrvasm20.inc ****     ldi     shift, 0x40         ;[7] reset data for receiving the next byte
+ 158:usbdrv/usbdrvasm20.inc ****     subi    leap, 0x55          ;[9] trick to introduce a leap cycle every 3 bytes
+ 159:usbdrv/usbdrvasm20.inc ****     brcc    nextInst            ;[10 or 11] it will fail after 85 bytes. However low speed can only
+ 160:usbdrv/usbdrvasm20.inc ****     dec     bitcnt              ;[11 or 12]
+ 161:usbdrv/usbdrvasm20.inc ****     brne    bit0                ;[12 or 13]
+ 162:usbdrv/usbdrvasm20.inc ****     ldi     x1, 1               ;[13 or 14] unstuffing bit 7
+ 163:usbdrv/usbdrvasm20.inc ****     in      bitcnt, USBIN       ;[0] sample stuff bit
+ 164:usbdrv/usbdrvasm20.inc ****     rjmp    unstuff             ;[1]
+ 165               	
+ 166               	b7handle0:
+ 167:usbdrv/usbdrvasm20.inc ****     mov     x2,x1               ;[5] Set x2 to current line state
+ 168:usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 6           ;[6]
+ 169:usbdrv/usbdrvasm20.inc ****     lsr     shift               ;[7] shift "0" into the data
+ 170:usbdrv/usbdrvasm20.inc ****     st      y+, shift           ;[8] store data into the buffer
+ 171:usbdrv/usbdrvasm20.inc ****     ldi     shift, 0x40         ;[10] reset data for receiving the next byte
+ 172:usbdrv/usbdrvasm20.inc ****     subi    leap, 0x55          ;[11] trick to introduce a leap cycle every 3 bytes
+ 173:usbdrv/usbdrvasm20.inc ****     brcs    bit0                ;[12] it will fail after 85 bytes. However low speed can only recei
+ 174:usbdrv/usbdrvasm20.inc ****     rjmp    bit0                ;[13]
+ 175               	
+ 176               	
+ 177               	;----------------------------------------------------------------------------
+ 178               	; Handle unstuff
+ 179               	; x1==0xFF indicate unstuffing bit6
+ 180               	;----------------------------------------------------------------------------
+ 181               	
+ 182               	unstuff6:
+ 183:usbdrv/usbdrvasm20.inc ****     ldi     x1,0xFF             ;[12] indicate unstuffing bit 6
+ 184:usbdrv/usbdrvasm20.inc ****     in      bitcnt, USBIN       ;[0]  sample stuff bit
+ 185:usbdrv/usbdrvasm20.inc ****     nop                         ;[1]  fix timing
+ 186               	unstuff:                        ;b0-5  b6   b7
+ 187:usbdrv/usbdrvasm20.inc ****     mov     x2,bitcnt           ;[3]  [2]  [3]  Set x2 to match line state
+ 188:usbdrv/usbdrvasm20.inc ****     subi    leap2, 0x55         ;[4]  [3]  [4]  delay loop
+ 189:usbdrv/usbdrvasm20.inc ****     brcs    nextInst            ;[5]  [4]  [5]  add one cycle every three stuff bits
+ 190:usbdrv/usbdrvasm20.inc ****     sbci    leap2,0             ;[6]  [5]  [6]
+ 191:usbdrv/usbdrvasm20.inc ****     ldi     bitcnt,6            ;[7]  [6]  [7]  reset bit stuff counter
+ 192:usbdrv/usbdrvasm20.inc ****     andi    x2, USBMASK         ;[8]  [7]  [8] only keep D+ and D-
+ 193:usbdrv/usbdrvasm20.inc ****     cpi     x1,0                ;[9]  [8]  [9]
+ 194:usbdrv/usbdrvasm20.inc ****     brmi    bit7                ;[10] [9]  [10] finished unstuffing bit6 When x1<0
+ 195:usbdrv/usbdrvasm20.inc ****     breq    bitloop             ;[11] ---  [11] finished unstuffing bit0-5 when x1=0
+ 196:usbdrv/usbdrvasm20.inc ****     nop                         ;---  ---  [12]
+ 197:usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;---  ---  [0] sample line state for bit0
+ 198:usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;---  ---  [1] filter only D+ and D- bits
+ 199:usbdrv/usbdrvasm20.inc ****     rjmp    handleBit           ;---  ---  [2] make bit0 14 cycles long
+ 200               	
+ 201               	;----------------------------------------------------------------------------
+ 202               	; Receiver loop (numbers in brackets are cycles within byte after instr)
+ 203               	;----------------------------------------------------------------------------
+ 204               	bitloop:
+ 205:usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;[0] sample line state
+ 206:usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+ 207:usbdrv/usbdrvasm20.inc ****     breq    se0                 ;[2] both lines are low so handle se0
+ 208               	handleBit:
+ 209:usbdrv/usbdrvasm20.inc ****     cpse    x1, x2              ;[3] when previous line state equals current line state, handle "1"
+ 210:usbdrv/usbdrvasm20.inc ****     rjmp    handle0             ;[4] when line state differs, handle "0"
+ 211:usbdrv/usbdrvasm20.inc ****     sec                         ;[5]
+ 212:usbdrv/usbdrvasm20.inc ****     ror     shift               ;[6] shift "1" into the data
+ 213:usbdrv/usbdrvasm20.inc ****     brcs    b6checkUnstuff      ;[7] When after shift C is set, next bit is bit7
+ 214:usbdrv/usbdrvasm20.inc ****     nop2                        ;[8]
+ 215:usbdrv/usbdrvasm20.inc ****     dec     bitcnt              ;[10]
+ 216:usbdrv/usbdrvasm20.inc ****     brne    bitloop             ;[11]
+ 217:usbdrv/usbdrvasm20.inc ****     ldi     x1,0                ;[12] indicate unstuff for bit other than bit6 or bit7
+ 218:usbdrv/usbdrvasm20.inc ****     in      bitcnt, USBIN       ;[0] sample stuff bit
+ 219:usbdrv/usbdrvasm20.inc ****     rjmp    unstuff             ;[1]
+ 220               	
+ 221               	handle0:
+ 222:usbdrv/usbdrvasm20.inc ****     mov     x2, x1              ;[6] Set x2 to current line state
+ 223:usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 6           ;[7] reset unstuff counter. 
+ 224:usbdrv/usbdrvasm20.inc ****     lsr     shift               ;[8] shift "0" into the data
+ 225:usbdrv/usbdrvasm20.inc ****     brcs    bit7                ;[9] When after shift C is set, next bit is bit7
+ 226:usbdrv/usbdrvasm20.inc ****     nop                         ;[10]
+ 227:usbdrv/usbdrvasm20.inc ****     rjmp    bitloop             ;[11] 
+ 228               	    
+ 229               	;----------------------------------------------------------------------------
+ 230               	; End of receive loop. Now start handling EOP
+ 231               	;----------------------------------------------------------------------------
+ 232               	
+ 233               	macro POP_STANDARD ; 14 cycles
+ 234               	    pop     cnt
+ 235               	    pop     x4
+ 236               	    pop     x3
+ 237               	    pop     x2
+ 238               	    pop     x1
+ 239               	    pop     shift
+ 240               	    pop     bitcnt
+ 241               	    endm
+ 242               	macro POP_RETI     ; 7 cycles
+ 243               	    pop     YH
+ 244               	    pop     YL
+ 245               	    out     SREG, YL
+ 246               	    pop     YL
+ 247               	    endm
+ 248               	
+ 249               	
+ 250               	
+ 251               	#include "asmcommon.inc"
+   1               	/* Name: asmcommon.inc
+   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+   3               	 * Author: Christian Starkjohann
+   4               	 * Creation Date: 2007-11-05
+   5               	 * Tabsize: 4
+   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+   8               	 * Revision: $Id$
+   9               	 */
+  10               	
+  11               	/* Do not link this file! Link usbdrvasm.S instead, which includes the
+  12               	 * appropriate implementation!
+  13               	 */
+  14               	
+  15               	/*
+  16               	General Description:
+  17               	This file contains assembler code which is shared among the USB driver
+  18               	implementations for different CPU cocks. Since the code must be inserted
+  19               	in the middle of the module, it's split out into this file and #included.
+  20               	
+  21               	Jump destinations called from outside:
+  22               	    sofError: Called when no start sequence was found.
+  23               	    se0: Called when a package has been successfully received.
+  24               	    overflow: Called when receive buffer overflows.
+  25               	    doReturn: Called after sending data.
+  26               	
+  27               	Outside jump destinations used by this module:
+  28               	    waitForJ: Called to receive an already arriving packet.
+  29               	    sendAckAndReti:
+  30               	    sendNakAndReti:
+  31               	    sendCntAndReti:
+  32               	    usbSendAndReti:
+  33               	
+  34               	The following macros must be defined before this file is included:
+  35               	    .macro POP_STANDARD
+  36               	    .endm
+  37               	    .macro POP_RETI
+  38               	    .endm
+  39               	*/
+  40               	
+  41               	#define token   x1
+  42               	
+  43               	overflow:
+  44:usbdrv/asmcommon.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT
+  45:usbdrv/asmcommon.inc ****     USB_STORE_PENDING(x2)       ; clear any pending interrupts
+  46               	ignorePacket:
+  47:usbdrv/asmcommon.inc ****     clr     token
+  48:usbdrv/asmcommon.inc ****     rjmp    storeTokenAndReturn
+  49               	
+  50               	;----------------------------------------------------------------------------
+  51               	; Processing of received packet (numbers in brackets are cycles after center of SE0)
+  52               	;----------------------------------------------------------------------------
+  53               	;This is the only non-error exit point for the software receiver loop
+  54               	;we don't check any CRCs here because there is no time left.
+  55               	se0:
+  56:usbdrv/asmcommon.inc ****     subi    cnt, USB_BUFSIZE    ;[5]
+  57:usbdrv/asmcommon.inc ****     neg     cnt                 ;[6]
+  58:usbdrv/asmcommon.inc ****     sub     YL, cnt             ;[7]
+  59:usbdrv/asmcommon.inc ****     sbci    YH, 0               ;[8]
+  60:usbdrv/asmcommon.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
+  61:usbdrv/asmcommon.inc ****     USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
+  62:usbdrv/asmcommon.inc ****     ld      token, y            ;[11]
+  63:usbdrv/asmcommon.inc ****     cpi     token, USBPID_DATA0 ;[13]
+  64:usbdrv/asmcommon.inc ****     breq    handleData          ;[14]
+  65:usbdrv/asmcommon.inc ****     cpi     token, USBPID_DATA1 ;[15]
+  66:usbdrv/asmcommon.inc ****     breq    handleData          ;[16]
+  67:usbdrv/asmcommon.inc ****     lds     shift, usbDeviceAddr;[17]
+  68:usbdrv/asmcommon.inc ****     ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
+  69:usbdrv/asmcommon.inc ****     lsl     x2                  ;[21] shift out 1 bit endpoint number
+  70:usbdrv/asmcommon.inc ****     cpse    x2, shift           ;[22]
+  71:usbdrv/asmcommon.inc ****     rjmp    ignorePacket        ;[23]
+  72               	/* only compute endpoint number in x3 if required later */
+  73               	#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
+  74:usbdrv/asmcommon.inc ****     ldd     x3, y+2             ;[24] endpoint number + crc
+  75:usbdrv/asmcommon.inc ****     rol     x3                  ;[26] shift in LSB of endpoint
+  76               	#endif
+  77:usbdrv/asmcommon.inc ****     cpi     token, USBPID_IN    ;[27]
+  78:usbdrv/asmcommon.inc ****     breq    handleIn            ;[28]
+  79:usbdrv/asmcommon.inc ****     cpi     token, USBPID_SETUP ;[29]
+  80:usbdrv/asmcommon.inc ****     breq    handleSetupOrOut    ;[30]
+  81:usbdrv/asmcommon.inc ****     cpi     token, USBPID_OUT   ;[31]
+  82:usbdrv/asmcommon.inc ****     brne    ignorePacket        ;[32] must be ack, nak or whatever
+  83               	;   rjmp    handleSetupOrOut    ; fallthrough
+  84               	
+  85               	;Setup and Out are followed by a data packet two bit times (16 cycles) after
+  86               	;the end of SE0. The sync code allows up to 40 cycles delay from the start of
+  87               	;the sync pattern until the first bit is sampled. That's a total of 56 cycles.
+  88               	handleSetupOrOut:               ;[32]
+  89               	#if USB_CFG_IMPLEMENT_FN_WRITEOUT   /* if we have data for endpoint != 0, set usbCurrentTok to addr
+  90               	    andi    x3, 0xf             ;[32]
+  91               	    breq    storeTokenAndReturn ;[33]
+  92               	    mov     token, x3           ;[34] indicate that this is endpoint x OUT
+  93               	#endif
+  94               	storeTokenAndReturn:
+  95:usbdrv/asmcommon.inc ****     sts     usbCurrentTok, token;[35]
+  96               	doReturn:
+  97:usbdrv/asmcommon.inc ****     POP_STANDARD                ;[37] 12...16 cycles
+  98:usbdrv/asmcommon.inc ****     USB_LOAD_PENDING(YL)        ;[49]
+  99:usbdrv/asmcommon.inc ****     sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
+ 100:usbdrv/asmcommon.inc ****     rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pendin
+ 101               	sofError:
+ 102:usbdrv/asmcommon.inc ****     POP_RETI                    ;macro call
+ 103:usbdrv/asmcommon.inc ****     reti
+ 104               	
+ 105               	handleData:
+ 106               	#if USB_CFG_CHECK_CRC
+ 107               	    CRC_CLEANUP_AND_CHECK       ; jumps to ignorePacket if CRC error
+ 108               	#endif
+ 109:usbdrv/asmcommon.inc ****     lds     shift, usbCurrentTok;[18]
+ 110:usbdrv/asmcommon.inc ****     tst     shift               ;[20]
+ 111:usbdrv/asmcommon.inc ****     breq    doReturn            ;[21]
+ 112:usbdrv/asmcommon.inc ****     lds     x2, usbRxLen        ;[22]
+ 113:usbdrv/asmcommon.inc ****     tst     x2                  ;[24]
+ 114:usbdrv/asmcommon.inc ****     brne    sendNakAndReti      ;[25]
+ 115               	; 2006-03-11: The following two lines fix a problem where the device was not
+ 116               	; recognized if usbPoll() was called less frequently than once every 4 ms.
+ 117:usbdrv/asmcommon.inc ****     cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and a
+ 118:usbdrv/asmcommon.inc ****     brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
+ 119               	#if USB_CFG_CHECK_DATA_TOGGLING
+ 120               	    sts     usbCurrentDataToken, token  ; store for checking by C code
+ 121               	#endif
+ 122:usbdrv/asmcommon.inc ****     sts     usbRxLen, cnt       ;[28] store received data, swap buffers
+ 123:usbdrv/asmcommon.inc ****     sts     usbRxToken, shift   ;[30]
+ 124:usbdrv/asmcommon.inc ****     lds     x2, usbInputBufOffset;[32] swap buffers
+ 125:usbdrv/asmcommon.inc ****     ldi     cnt, USB_BUFSIZE    ;[34]
+ 126:usbdrv/asmcommon.inc ****     sub     cnt, x2             ;[35]
+ 127:usbdrv/asmcommon.inc ****     sts     usbInputBufOffset, cnt;[36] buffers now swapped
+ 128:usbdrv/asmcommon.inc ****     rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
+ 129               	
+ 130               	handleIn:
+ 131               	;We don't send any data as long as the C code has not processed the current
+ 132               	;input data and potentially updated the output data. That's more efficient
+ 133               	;in terms of code size than clearing the tx buffers when a packet is received.
+ 134:usbdrv/asmcommon.inc ****     lds     x1, usbRxLen        ;[30]
+ 135:usbdrv/asmcommon.inc ****     cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
+ 136:usbdrv/asmcommon.inc ****     brge    sendNakAndReti      ;[33] unprocessed input packet?
+ 137:usbdrv/asmcommon.inc ****     ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
+ 138               	#if USB_CFG_HAVE_INTRIN_ENDPOINT
+ 139:usbdrv/asmcommon.inc ****     andi    x3, 0xf             ;[35] x3 contains endpoint
+ 140               	#if USB_CFG_SUPPRESS_INTR_CODE
+ 141               	    brne    sendNakAndReti      ;[36]
+ 142               	#else
+ 143:usbdrv/asmcommon.inc ****     brne    handleIn1           ;[36]
+ 144               	#endif
+ 145               	#endif
+ 146:usbdrv/asmcommon.inc ****     lds     cnt, usbTxLen       ;[37]
+ 147:usbdrv/asmcommon.inc ****     sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
+ 148:usbdrv/asmcommon.inc ****     rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
+ 149:usbdrv/asmcommon.inc ****     sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
+ 150:usbdrv/asmcommon.inc ****     ldi     YL, lo8(usbTxBuf)   ;[43]
+ 151:usbdrv/asmcommon.inc ****     ldi     YH, hi8(usbTxBuf)   ;[44]
+ 152:usbdrv/asmcommon.inc ****     rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
+ 153               	
+ 154               	; Comment about when to set usbTxLen to USBPID_NAK:
+ 155               	; We should set it back when we receive the ACK from the host. This would
+ 156               	; be simple to implement: One static variable which stores whether the last
+ 157               	; tx was for endpoint 0 or 1 and a compare in the receiver to distinguish the
+ 158               	; ACK. However, we set it back immediately when we send the package,
+ 159               	; assuming that no error occurs and the host sends an ACK. We save one byte
+ 160               	; RAM this way and avoid potential problems with endless retries. The rest of
+ 161               	; the driver assumes error-free transfers anyway.
+ 162               	
+ 163               	#if !USB_CFG_SUPPRESS_INTR_CODE && USB_CFG_HAVE_INTRIN_ENDPOINT /* placed here due to relative jump
+ 164               	handleIn1:                      ;[38]
+ 165               	#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+ 166               	; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
+ 167               	    cpi     x3, USB_CFG_EP3_NUMBER;[38]
+ 168               	    breq    handleIn3           ;[39]
+ 169               	#endif
+ 170:usbdrv/asmcommon.inc ****     lds     cnt, usbTxLen1      ;[40]
+ 171:usbdrv/asmcommon.inc ****     sbrc    cnt, 4              ;[42] all handshake tokens have bit 4 set
+ 172:usbdrv/asmcommon.inc ****     rjmp    sendCntAndReti      ;[43] 47 + 16 = 63 until SOP
+ 173:usbdrv/asmcommon.inc ****     sts     usbTxLen1, x1       ;[44] x1 == USBPID_NAK from above
+ 174:usbdrv/asmcommon.inc ****     ldi     YL, lo8(usbTxBuf1)  ;[46]
+ 175:usbdrv/asmcommon.inc ****     ldi     YH, hi8(usbTxBuf1)  ;[47]
+ 176:usbdrv/asmcommon.inc ****     rjmp    usbSendAndReti      ;[48] 50 + 12 = 62 until SOP
+ 177               	
+ 252               	
+ 253               	; USB spec says:
+ 254               	; idle = J
+ 255               	; J = (D+ = 0), (D- = 1)
+ 256               	; K = (D+ = 1), (D- = 0)
+ 257               	; Spec allows 7.5 bit times from EOP to SOP for replies
+ 258               	; 7.5 bit times is 100 cycles. This implementation arrives a bit later at se0
+ 259               	; then specified in the include file but there is plenty of time
+ 260               	
+ 261               	bitstuffN:
+ 262:usbdrv/usbdrvasm20.inc ****     eor     x1, x4          ;[8]
+ 263:usbdrv/usbdrvasm20.inc ****     ldi     x2, 0           ;[9]
+ 264:usbdrv/usbdrvasm20.inc ****     nop2                    ;[10]
+ 265:usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[12] <-- out
+ 266:usbdrv/usbdrvasm20.inc ****     rjmp    didStuffN       ;[0]
+ 267               	    
+ 268               	bitstuff7:
+ 269:usbdrv/usbdrvasm20.inc ****     eor     x1, x4          ;[6]
+ 270:usbdrv/usbdrvasm20.inc ****     ldi     x2, 0           ;[7] Carry is zero due to brcc
+ 271:usbdrv/usbdrvasm20.inc ****     rol     shift           ;[8] compensate for ror shift at branch destination
+ 272:usbdrv/usbdrvasm20.inc ****     nop2                    ;[9]
+ 273:usbdrv/usbdrvasm20.inc ****     rjmp    didStuff7       ;[11]
+ 274               	
+ 275               	sendNakAndReti:
+ 276:usbdrv/usbdrvasm20.inc ****     ldi     x3, USBPID_NAK  ;[-18]
+ 277:usbdrv/usbdrvasm20.inc ****     rjmp    sendX3AndReti   ;[-17]
+ 278               	sendAckAndReti:
+ 279:usbdrv/usbdrvasm20.inc ****     ldi     cnt, USBPID_ACK ;[-17]
+ 280               	sendCntAndReti:
+ 281:usbdrv/usbdrvasm20.inc ****     mov     x3, cnt         ;[-16]
+ 282               	sendX3AndReti:
+ 283:usbdrv/usbdrvasm20.inc ****     ldi     YL, 20          ;[-15] x3==r20 address is 20
+ 284:usbdrv/usbdrvasm20.inc ****     ldi     YH, 0           ;[-14]
+ 285:usbdrv/usbdrvasm20.inc ****     ldi     cnt, 2          ;[-13]
+ 286               	;   rjmp    usbSendAndReti      fallthrough
+ 287               	
+ 288               	;usbSend:
+ 289               	;pointer to data in 'Y'
+ 290               	;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+ 291               	;uses: x1...x4, btcnt, shift, cnt, Y
+ 292               	;Numbers in brackets are time since first bit of sync pattern is sent
+ 293               	;We don't match the transfer rate exactly (don't insert leap cycles every third
+ 294               	;byte) because the spec demands only 1.5% precision anyway.
+ 295               	usbSendAndReti:             ; 12 cycles until SOP
+ 296:usbdrv/usbdrvasm20.inc ****     in      x2, USBDDR      ;[-12]
+ 297:usbdrv/usbdrvasm20.inc ****     ori     x2, USBMASK     ;[-11]
+ 298:usbdrv/usbdrvasm20.inc ****     sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+ 299:usbdrv/usbdrvasm20.inc ****     in      x1, USBOUT      ;[-8] port mirror for tx loop
+ 300:usbdrv/usbdrvasm20.inc ****     out     USBDDR, x2      ;[-7] <- acquire bus
+ 301               	; need not init x2 (bitstuff history) because sync starts with 0
+ 302:usbdrv/usbdrvasm20.inc ****     ldi     x4, USBMASK     ;[-6] exor mask
+ 303:usbdrv/usbdrvasm20.inc ****     ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+ 304               	txByteLoop:
+ 305:usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 0x49    ;[-4]        [10] binary 01001001
+ 306               	txBitLoop:
+ 307:usbdrv/usbdrvasm20.inc ****     sbrs    shift, 0        ;[-3] [10]   [11]
+ 308:usbdrv/usbdrvasm20.inc ****     eor     x1, x4          ;[-2] [11]   [12]
+ 309:usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[-1] [12]   [13]   <-- out N
+ 310:usbdrv/usbdrvasm20.inc ****     ror     shift           ;[0]  [13]   [14]
+ 311:usbdrv/usbdrvasm20.inc ****     ror     x2              ;[1]
+ 312               	didStuffN:
+ 313:usbdrv/usbdrvasm20.inc ****     nop2                    ;[2]
+ 314:usbdrv/usbdrvasm20.inc ****     nop                     ;[4]
+ 315:usbdrv/usbdrvasm20.inc ****     cpi     x2, 0xfc        ;[5]
+ 316:usbdrv/usbdrvasm20.inc ****     brcc    bitstuffN       ;[6]
+ 317:usbdrv/usbdrvasm20.inc ****     lsr     bitcnt          ;[7]
+ 318:usbdrv/usbdrvasm20.inc ****     brcc    txBitLoop       ;[8]
+ 319:usbdrv/usbdrvasm20.inc ****     brne    txBitLoop       ;[9]
+ 320               	
+ 321:usbdrv/usbdrvasm20.inc ****     sbrs    shift, 0        ;[10]
+ 322:usbdrv/usbdrvasm20.inc ****     eor     x1, x4          ;[11]
+ 323               	didStuff7:
+ 324:usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[-1] [13] <-- out 7
+ 325:usbdrv/usbdrvasm20.inc ****     ror     shift           ;[0] [14]
+ 326:usbdrv/usbdrvasm20.inc ****     ror     x2              ;[1]
+ 327:usbdrv/usbdrvasm20.inc ****     nop                     ;[2]
+ 328:usbdrv/usbdrvasm20.inc ****     cpi     x2, 0xfc        ;[3]
+ 329:usbdrv/usbdrvasm20.inc ****     brcc    bitstuff7       ;[4]
+ 330:usbdrv/usbdrvasm20.inc ****     ld      shift, y+       ;[5]
+ 331:usbdrv/usbdrvasm20.inc ****     dec     cnt             ;[7]
+ 332:usbdrv/usbdrvasm20.inc ****     brne    txByteLoop      ;[8]
+ 333               	;make SE0:
+ 334:usbdrv/usbdrvasm20.inc ****     cbr     x1, USBMASK     ;[9] prepare SE0 [spec says EOP may be 25 to 30 cycles]
+ 335:usbdrv/usbdrvasm20.inc ****     lds     x2, usbNewDeviceAddr;[10]
+ 336:usbdrv/usbdrvasm20.inc ****     lsl     x2              ;[12] we compare with left shifted address
+ 337:usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[13] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+ 338:usbdrv/usbdrvasm20.inc ****     subi    YL, 20 + 2      ;[0] Only assign address on data packets, not ACK/NAK in x3
+ 339:usbdrv/usbdrvasm20.inc ****     sbci    YH, 0           ;[1]
+ 340               	;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+ 341               	;set address only after data packet was sent, not after handshake
+ 342:usbdrv/usbdrvasm20.inc ****     breq    skipAddrAssign  ;[2]
+ 343:usbdrv/usbdrvasm20.inc ****     sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+ 344               	skipAddrAssign:
+ 345               	;end of usbDeviceAddress transfer
+ 346:usbdrv/usbdrvasm20.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+ 347:usbdrv/usbdrvasm20.inc ****     USB_STORE_PENDING(x2)   ;[5]
+ 348:usbdrv/usbdrvasm20.inc ****     ori     x1, USBIDLE     ;[6]
+ 349:usbdrv/usbdrvasm20.inc ****     in      x2, USBDDR      ;[7]
+ 350:usbdrv/usbdrvasm20.inc ****     cbr     x2, USBMASK     ;[8] set both pins to input
+ 351:usbdrv/usbdrvasm20.inc ****     mov     x3, x1          ;[9]
+ 352:usbdrv/usbdrvasm20.inc ****     cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+ 353:usbdrv/usbdrvasm20.inc ****     ldi     x4, 5           ;[11]
+ 354               	se0Delay:
+ 355:usbdrv/usbdrvasm20.inc ****     dec     x4              ;[12] [15] [18] [21] [24]
+ 356:usbdrv/usbdrvasm20.inc ****     brne    se0Delay        ;[13] [16] [19] [22] [25]
+ 357:usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[26] <-- out J (idle) -- end of SE0 (EOP signal)
+ 358:usbdrv/usbdrvasm20.inc ****     out     USBDDR, x2      ;[27] <-- release bus now
+ 359:usbdrv/usbdrvasm20.inc ****     out     USBOUT, x3      ;[28] <-- ensure no pull-up resistors are active
+ 360:usbdrv/usbdrvasm20.inc ****     rjmp    doReturn
+ 361               	...
+DEFINED SYMBOLS
+usbdrv/usbdrvasm20.inc:49     .text:00000032 __vector_1
+  usbdrv/usbdrvasm.S:233    .text:00000000 usbCrc16
+  usbdrv/usbdrvasm.S:265    .text:0000002a usbCrc16Append
+  usbdrv/usbdrvasm.S:255    .text:00000024 usbCrcLoopEntry
+  usbdrv/usbdrvasm.S:243    .text:00000012 usbCrcByteLoop
+  usbdrv/usbdrvasm.S:246    .text:00000016 usbCrcBitLoop
+  usbdrv/usbdrvasm.S:252    .text:00000020 usbCrcNoXor
+  usbdrv/usbdrvasm.S:258    .text:00000028 usbCrcReady
+usbdrv/usbdrvasm20.inc:63     .text:0000003a waitForJ
+usbdrv/usbdrvasm20.inc:67     .text:00000040 waitForK
+usbdrv/usbdrvasm20.inc:96     .text:00000066 foundK
+usbdrv/asmcommon.inc:101    .text:0000016c sofError
+usbdrv/usbdrvasm20.inc:125    .text:00000084 haveTwoBitsK
+usbdrv/usbdrvasm20.inc:135    .text:00000096 bit0
+usbdrv/usbdrvasm20.inc:208    .text:000000f8 handleBit
+usbdrv/usbdrvasm20.inc:144    .text:0000009c b6checkUnstuff
+usbdrv/usbdrvasm20.inc:182    .text:000000d2 unstuff6
+usbdrv/usbdrvasm20.inc:147    .text:000000a0 bit7
+usbdrv/asmcommon.inc:43     .text:0000011a overflow
+usbdrv/usbdrvasm20.inc:166    .text:000000c2 b7handle0
+usbdrv/usbdrvasm20.inc:186    .text:000000d8 unstuff
+usbdrv/usbdrvasm20.inc:204    .text:000000f2 bitloop
+usbdrv/asmcommon.inc:55     .text:00000122 se0
+usbdrv/usbdrvasm20.inc:221    .text:0000010e handle0
+usbdrv/asmcommon.inc:46     .text:0000011e ignorePacket
+usbdrv/asmcommon.inc:94     .text:00000154 storeTokenAndReturn
+usbdrv/asmcommon.inc:105    .text:00000176 handleData
+usbdrv/asmcommon.inc:130    .text:000001a0 handleIn
+usbdrv/asmcommon.inc:88     .text:00000154 handleSetupOrOut
+usbdrv/asmcommon.inc:96     .text:00000158 doReturn
+usbdrv/usbdrvasm20.inc:275    .text:000001e6 sendNakAndReti
+usbdrv/usbdrvasm20.inc:278    .text:000001ea sendAckAndReti
+usbdrv/asmcommon.inc:164    .text:000001c0 handleIn1
+usbdrv/usbdrvasm20.inc:280    .text:000001ec sendCntAndReti
+usbdrv/usbdrvasm20.inc:295    .text:000001f4 usbSendAndReti
+usbdrv/usbdrvasm20.inc:261    .text:000001d2 bitstuffN
+usbdrv/usbdrvasm20.inc:312    .text:0000020e didStuffN
+usbdrv/usbdrvasm20.inc:268    .text:000001dc bitstuff7
+usbdrv/usbdrvasm20.inc:323    .text:00000220 didStuff7
+usbdrv/usbdrvasm20.inc:282    .text:000001ee sendX3AndReti
+usbdrv/usbdrvasm20.inc:304    .text:00000202 txByteLoop
+usbdrv/usbdrvasm20.inc:306    .text:00000204 txBitLoop
+usbdrv/usbdrvasm20.inc:344    .text:00000246 skipAddrAssign
+usbdrv/usbdrvasm20.inc:354    .text:00000256 se0Delay
+
+UNDEFINED SYMBOLS
+usbInputBufOffset
+usbRxBuf
+usbDeviceAddr
+usbCurrentTok
+usbRxLen
+usbRxToken
+usbTxLen
+usbTxBuf
+usbTxStatus1
+usbNewDeviceAddr
BinÃ¤rdateien usbdrv/usbdrvasm.o and /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrvasm.o sind verschieden.
diff --unified --recursive --new-file usbdrv/usbdrvasm.S /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrvasm.S
--- usbdrv/usbdrvasm.S	2010-07-27 19:39:24.000000000 +0200
+++ /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrvasm.S	2011-02-11 19:19:30.725694273 +0100
@@ -363,6 +363,7 @@
 #ifndef USB_CFG_CLOCK_KHZ
 #   ifdef F_CPU
 #       define USB_CFG_CLOCK_KHZ (F_CPU/1000)
+#error "test " USB_CFG_CLOCK_KHZ
 #   else
 #       error "USB_CFG_CLOCK_KHZ not defined in usbconfig.h and no F_CPU set!"
 #   endif
diff --unified --recursive --new-file usbdrv/usbdrv.c /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrv.c
--- usbdrv/usbdrv.c	2010-07-27 19:39:24.000000000 +0200
+++ /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrv.c	2011-02-25 20:38:04.377554002 +0100
@@ -10,7 +10,9 @@
 
 #include "usbportability.h"
 #include "usbdrv.h"
+#if DEBUG_LEVEL > 0
 #include "oddebug.h"
+#endif
 
 /*
 General Description:
@@ -239,7 +241,9 @@
     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
     usbCrc16Append(&txStatus->buffer[1], len);
     txStatus->len = len + 4;    /* len must be given including sync byte */
+#if DEBUG_LEVEL > 0
     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
+#endif
 }
 
 USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
@@ -428,7 +432,9 @@
  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
  * 0...0x0f for OUT on endpoint X
  */
+#if DEBUG_LEVEL > 0
     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
+#endif
     USB_RX_USER_HOOK(data, len)
 #if USB_CFG_IMPLEMENT_FN_WRITEOUT
     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
@@ -542,7 +548,9 @@
         usbMsgLen = USB_NO_MSG;
     }
     usbTxLen = len;
+#if DEBUG_LEVEL > 0
     DBG2(0x20, usbTxBuf, len-1);
+#endif
 }
 
 /* ------------------------------------------------------------------------- */
@@ -597,7 +605,9 @@
     usbNewDeviceAddr = 0;
     usbDeviceAddr = 0;
     usbResetStall();
+#if DEBUG_LEVEL > 0
     DBG1(0xff, 0, 0);
+#endif
 isNotReset:
     usbHandleResetHook(i);
 }
diff --unified --recursive --new-file usbdrv/usbdrv.lst /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrv.lst
--- usbdrv/usbdrv.lst	1970-01-01 01:00:00.000000000 +0100
+++ /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrv.lst	2011-03-02 11:51:54.000000000 +0100
@@ -0,0 +1,392 @@
+   1               		.file	"usbdrv.c"
+   2               	__SREG__ = 0x3f
+   3               	__SP_H__ = 0x3e
+   4               	__SP_L__ = 0x3d
+   5               	__CCP__  = 0x34
+   6               	__tmp_reg__ = 0
+   7               	__zero_reg__ = 1
+   8               		.text
+   9               	.global	usbInit
+  11               	usbInit:
+  12               	/* prologue: function */
+  13               	/* frame size = 0 */
+  14 0000 E9E6      		ldi r30,lo8(105)
+  15 0002 F0E0      		ldi r31,hi8(105)
+  16 0004 8081      		ld r24,Z
+  17 0006 8260      		ori r24,lo8(2)
+  18 0008 8083      		st Z,r24
+  19 000a E89A      		sbi 61-32,0
+  20 000c 8BE4      		ldi r24,lo8(75)
+  21 000e 8093 0000 		sts usbTxStatus1+1,r24
+  22 0012 8AE5      		ldi r24,lo8(90)
+  23 0014 8093 0000 		sts usbTxStatus1,r24
+  24               	/* epilogue start */
+  25 0018 0895      		ret
+  27               	.global	usbSetInterrupt
+  29               	usbSetInterrupt:
+  30 001a 1F93      		push r17
+  31               	/* prologue: function */
+  32               	/* frame size = 0 */
+  33 001c DC01      		movw r26,r24
+  34 001e 162F      		mov r17,r22
+  35 0020 8091 0000 		lds r24,usbTxStatus1
+  36 0024 84FF      		sbrs r24,4
+  37 0026 00C0      		rjmp .L4
+  38 0028 8091 0000 		lds r24,usbTxStatus1+1
+  39 002c 98E8      		ldi r25,lo8(-120)
+  40 002e 8927      		eor r24,r25
+  41 0030 8093 0000 		sts usbTxStatus1+1,r24
+  42 0034 00C0      		rjmp .L5
+  43               	.L4:
+  44 0036 8AE5      		ldi r24,lo8(90)
+  45 0038 8093 0000 		sts usbTxStatus1,r24
+  46               	.L5:
+  47 003c 912F      		mov r25,r17
+  48 003e E0E0      		ldi r30,lo8(usbTxStatus1+2)
+  49 0040 F0E0      		ldi r31,hi8(usbTxStatus1+2)
+  50               	.L6:
+  51 0042 8D91      		ld r24,X+
+  52 0044 8193      		st Z+,r24
+  53 0046 9150      		subi r25,lo8(-(-1))
+  54 0048 01F4      		brne .L6
+  55 004a 80E0      		ldi r24,lo8(usbTxStatus1+2)
+  56 004c 90E0      		ldi r25,hi8(usbTxStatus1+2)
+  57 004e 612F      		mov r22,r17
+  58 0050 0E94 0000 		call usbCrc16Append
+  59 0054 1C5F      		subi r17,lo8(-(4))
+  60 0056 1093 0000 		sts usbTxStatus1,r17
+  61               	/* epilogue start */
+  62 005a 1F91      		pop r17
+  63 005c 0895      		ret
+  65               	.global	usbPoll
+  67               	usbPoll:
+  68 005e 1F93      		push r17
+  69 0060 CF93      		push r28
+  70 0062 DF93      		push r29
+  71               	/* prologue: function */
+  72               	/* frame size = 0 */
+  73 0064 9091 0000 		lds r25,usbRxLen
+  74 0068 9350      		subi r25,lo8(-(-3))
+  75 006a 97FD      		sbrc r25,7
+  76 006c 00C0      		rjmp .L9
+  77 006e 2091 0000 		lds r18,usbInputBufOffset
+  78 0072 8091 0000 		lds r24,usbRxToken
+  79 0076 8D32      		cpi r24,lo8(45)
+  80 0078 01F0      		breq .+2
+  81 007a 00C0      		rjmp .L10
+  82 007c 9830      		cpi r25,lo8(8)
+  83 007e 01F0      		breq .+2
+  84 0080 00C0      		rjmp .L10
+  85 0082 CCE0      		ldi r28,lo8(12)
+  86 0084 D0E0      		ldi r29,hi8(12)
+  87 0086 C21B      		sub r28,r18
+  88 0088 D109      		sbc r29,__zero_reg__
+  89 008a C050      		subi r28,lo8(-(usbRxBuf))
+  90 008c D040      		sbci r29,hi8(-(usbRxBuf))
+  91 008e 83EC      		ldi r24,lo8(-61)
+  92 0090 8093 0000 		sts usbTxBuf,r24
+  93 0094 8AE5      		ldi r24,lo8(90)
+  94 0096 8093 0000 		sts usbTxLen,r24
+  95 009a 1092 0000 		sts usbMsgFlags,__zero_reg__
+  96 009e 8881      		ld r24,Y
+  97 00a0 8076      		andi r24,lo8(96)
+  98 00a2 01F0      		breq .L11
+  99 00a4 CE01      		movw r24,r28
+ 100 00a6 0E94 0000 		call usbFunctionSetup
+ 101 00aa 282F      		mov r18,r24
+ 102 00ac 00C0      		rjmp .L12
+ 103               	.L11:
+ 104 00ae 9A81      		ldd r25,Y+2
+ 105 00b0 1092 0000 		sts usbTxBuf+9,__zero_reg__
+ 106 00b4 8981      		ldd r24,Y+1
+ 107 00b6 8823      		tst r24
+ 108 00b8 01F4      		brne .L13
+ 109 00ba 1092 0000 		sts usbTxBuf+10,__zero_reg__
+ 110 00be 22E0      		ldi r18,lo8(2)
+ 111 00c0 00C0      		rjmp .L49
+ 112               	.L13:
+ 113 00c2 8530      		cpi r24,lo8(5)
+ 114 00c4 01F4      		brne .L15
+ 115 00c6 9093 0000 		sts usbNewDeviceAddr,r25
+ 116 00ca 00C0      		rjmp .L50
+ 117               	.L15:
+ 118 00cc 8630      		cpi r24,lo8(6)
+ 119 00ce 01F4      		brne .L16
+ 120 00d0 8B81      		ldd r24,Y+3
+ 121 00d2 8130      		cpi r24,lo8(1)
+ 122 00d4 01F4      		brne .L17
+ 123 00d6 80E0      		ldi r24,lo8(usbDescriptorDevice)
+ 124 00d8 90E0      		ldi r25,hi8(usbDescriptorDevice)
+ 125 00da 9093 0000 		sts (usbMsgPtr)+1,r25
+ 126 00de 8093 0000 		sts usbMsgPtr,r24
+ 127 00e2 80E0      		ldi r24,lo8(0)
+ 128 00e4 22E1      		ldi r18,lo8(18)
+ 129 00e6 00C0      		rjmp .L18
+ 130               	.L17:
+ 131 00e8 8230      		cpi r24,lo8(2)
+ 132 00ea 01F0      		breq .L48
+ 133               	.L19:
+ 134 00ec 8330      		cpi r24,lo8(3)
+ 135 00ee 01F4      		brne .L20
+ 136 00f0 8A81      		ldd r24,Y+2
+ 137 00f2 8823      		tst r24
+ 138 00f4 01F4      		brne .L21
+ 139 00f6 80E0      		ldi r24,lo8(usbDescriptorString0)
+ 140 00f8 90E0      		ldi r25,hi8(usbDescriptorString0)
+ 141 00fa 9093 0000 		sts (usbMsgPtr)+1,r25
+ 142 00fe 8093 0000 		sts usbMsgPtr,r24
+ 143 0102 80E4      		ldi r24,lo8(64)
+ 144 0104 24E0      		ldi r18,lo8(4)
+ 145 0106 00C0      		rjmp .L18
+ 146               	.L21:
+ 147 0108 8130      		cpi r24,lo8(1)
+ 148 010a 01F0      		breq .L48
+ 149               	.L22:
+ 150 010c 8230      		cpi r24,lo8(2)
+ 151 010e 01F0      		breq .L48
+ 152               	.L23:
+ 153 0110 8330      		cpi r24,lo8(3)
+ 154 0112 01F4      		brne .L24
+ 155 0114 00C0      		rjmp .L48
+ 156               	.L20:
+ 157 0116 8132      		cpi r24,lo8(33)
+ 158 0118 01F4      		brne .L25
+ 159 011a 80E0      		ldi r24,lo8(usbDescriptorConfiguration+18)
+ 160 011c 90E0      		ldi r25,hi8(usbDescriptorConfiguration+18)
+ 161 011e 9093 0000 		sts (usbMsgPtr)+1,r25
+ 162 0122 8093 0000 		sts usbMsgPtr,r24
+ 163 0126 80E4      		ldi r24,lo8(64)
+ 164 0128 29E0      		ldi r18,lo8(9)
+ 165 012a 00C0      		rjmp .L18
+ 166               	.L25:
+ 167 012c 8232      		cpi r24,lo8(34)
+ 168 012e 01F4      		brne .L24
+ 169               	.L48:
+ 170 0130 CE01      		movw r24,r28
+ 171 0132 0E94 0000 		call usbFunctionDescriptor
+ 172 0136 282F      		mov r18,r24
+ 173 0138 80E0      		ldi r24,lo8(0)
+ 174 013a 00C0      		rjmp .L18
+ 175               	.L24:
+ 176 013c 80E4      		ldi r24,lo8(64)
+ 177 013e 20E0      		ldi r18,lo8(0)
+ 178               	.L18:
+ 179 0140 8093 0000 		sts usbMsgFlags,r24
+ 180 0144 00C0      		rjmp .L12
+ 181               	.L16:
+ 182 0146 8830      		cpi r24,lo8(8)
+ 183 0148 01F4      		brne .L26
+ 184 014a 21E0      		ldi r18,lo8(1)
+ 185 014c 80E0      		ldi r24,lo8(usbConfiguration)
+ 186 014e 90E0      		ldi r25,hi8(usbConfiguration)
+ 187 0150 00C0      		rjmp .L14
+ 188               	.L26:
+ 189 0152 8930      		cpi r24,lo8(9)
+ 190 0154 01F4      		brne .L27
+ 191 0156 9093 0000 		sts usbConfiguration,r25
+ 192 015a 00C0      		rjmp .L50
+ 193               	.L27:
+ 194 015c 8A30      		cpi r24,lo8(10)
+ 195 015e 01F4      		brne .L28
+ 196 0160 21E0      		ldi r18,lo8(1)
+ 197 0162 00C0      		rjmp .L49
+ 198               	.L28:
+ 199 0164 8B30      		cpi r24,lo8(11)
+ 200 0166 01F4      		brne .L50
+ 201               	.L29:
+ 202 0168 8BE4      		ldi r24,lo8(75)
+ 203 016a 8093 0000 		sts usbTxStatus1+1,r24
+ 204               	.L50:
+ 205 016e 20E0      		ldi r18,lo8(0)
+ 206               	.L49:
+ 207 0170 80E0      		ldi r24,lo8(usbTxBuf+9)
+ 208 0172 90E0      		ldi r25,hi8(usbTxBuf+9)
+ 209               	.L14:
+ 210 0174 9093 0000 		sts (usbMsgPtr)+1,r25
+ 211 0178 8093 0000 		sts usbMsgPtr,r24
+ 212 017c 00C0      		rjmp .L30
+ 213               	.L12:
+ 214 017e 2F3F      		cpi r18,lo8(-1)
+ 215 0180 01F4      		brne .L30
+ 216 0182 8881      		ld r24,Y
+ 217 0184 87FD      		sbrc r24,7
+ 218 0186 2E81      		ldd r18,Y+6
+ 219               	.L31:
+ 220 0188 80E8      		ldi r24,lo8(-128)
+ 221 018a 8093 0000 		sts usbMsgFlags,r24
+ 222 018e 00C0      		rjmp .L33
+ 223               	.L30:
+ 224 0190 8F81      		ldd r24,Y+7
+ 225 0192 8823      		tst r24
+ 226 0194 01F4      		brne .L33
+ 227 0196 8E81      		ldd r24,Y+6
+ 228 0198 8217      		cp r24,r18
+ 229 019a 00F0      		brlo .L32
+ 230               	.L33:
+ 231 019c 822F      		mov r24,r18
+ 232               	.L32:
+ 233 019e 8093 0000 		sts usbMsgLen,r24
+ 234               	.L10:
+ 235 01a2 1092 0000 		sts usbRxLen,__zero_reg__
+ 236               	.L9:
+ 237 01a6 8091 0000 		lds r24,usbTxLen
+ 238 01aa 84FF      		sbrs r24,4
+ 239 01ac 00C0      		rjmp .L34
+ 240 01ae 8091 0000 		lds r24,usbMsgLen
+ 241 01b2 8F3F      		cpi r24,lo8(-1)
+ 242 01b4 01F4      		brne .+2
+ 243 01b6 00C0      		rjmp .L34
+ 244 01b8 182F      		mov r17,r24
+ 245 01ba 8930      		cpi r24,lo8(9)
+ 246 01bc 00F0      		brlo .L35
+ 247 01be 18E0      		ldi r17,lo8(8)
+ 248               	.L35:
+ 249 01c0 811B      		sub r24,r17
+ 250 01c2 8093 0000 		sts usbMsgLen,r24
+ 251 01c6 8091 0000 		lds r24,usbTxBuf
+ 252 01ca 98E8      		ldi r25,lo8(-120)
+ 253 01cc 8927      		eor r24,r25
+ 254 01ce 8093 0000 		sts usbTxBuf,r24
+ 255 01d2 1123      		tst r17
+ 256 01d4 01F0      		breq .L36
+ 257 01d6 8091 0000 		lds r24,usbMsgFlags
+ 258 01da 87FF      		sbrs r24,7
+ 259 01dc 00C0      		rjmp .L37
+ 260 01de 80E0      		ldi r24,lo8(usbTxBuf+1)
+ 261 01e0 90E0      		ldi r25,hi8(usbTxBuf+1)
+ 262 01e2 612F      		mov r22,r17
+ 263 01e4 0E94 0000 		call usbFunctionRead
+ 264 01e8 182F      		mov r17,r24
+ 265 01ea 8930      		cpi r24,lo8(9)
+ 266 01ec 00F4      		brsh .L47
+ 267 01ee 00C0      		rjmp .L36
+ 268               	.L37:
+ 269 01f0 E091 0000 		lds r30,usbMsgPtr
+ 270 01f4 F091 0000 		lds r31,(usbMsgPtr)+1
+ 271 01f8 86FF      		sbrs r24,6
+ 272 01fa 00C0      		rjmp .L39
+ 273 01fc 912F      		mov r25,r17
+ 274 01fe A0E0      		ldi r26,lo8(usbTxBuf+1)
+ 275 0200 B0E0      		ldi r27,hi8(usbTxBuf+1)
+ 276               	.L40:
+ 277               	/* #APP */
+ 278               	 ;  510 "usbdrv/usbdrv.c" 1
+ 279 0202 8491      		lpm r24, Z
+ 280               		
+ 281               	 ;  0 "" 2
+ 282               	/* #NOAPP */
+ 283 0204 8D93      		st X+,r24
+ 284 0206 3196      		adiw r30,1
+ 285 0208 9150      		subi r25,lo8(-(-1))
+ 286 020a 01F4      		brne .L40
+ 287 020c 00C0      		rjmp .L41
+ 288               	.L39:
+ 289 020e 912F      		mov r25,r17
+ 290 0210 A0E0      		ldi r26,lo8(usbTxBuf+1)
+ 291 0212 B0E0      		ldi r27,hi8(usbTxBuf+1)
+ 292               	.L42:
+ 293 0214 8191      		ld r24,Z+
+ 294 0216 8D93      		st X+,r24
+ 295 0218 9150      		subi r25,lo8(-(-1))
+ 296 021a 01F4      		brne .L42
+ 297               	.L41:
+ 298 021c F093 0000 		sts (usbMsgPtr)+1,r31
+ 299 0220 E093 0000 		sts usbMsgPtr,r30
+ 300               	.L36:
+ 301 0224 80E0      		ldi r24,lo8(usbTxBuf+1)
+ 302 0226 90E0      		ldi r25,hi8(usbTxBuf+1)
+ 303 0228 612F      		mov r22,r17
+ 304 022a 0E94 0000 		call usbCrc16Append
+ 305 022e 612F      		mov r22,r17
+ 306 0230 6C5F      		subi r22,lo8(-(4))
+ 307 0232 6C30      		cpi r22,lo8(12)
+ 308 0234 01F0      		breq .L43
+ 309 0236 8FEF      		ldi r24,lo8(-1)
+ 310 0238 8093 0000 		sts usbMsgLen,r24
+ 311 023c 00C0      		rjmp .L43
+ 312               	.L47:
+ 313 023e 8FEF      		ldi r24,lo8(-1)
+ 314 0240 8093 0000 		sts usbMsgLen,r24
+ 315 0244 6EE1      		ldi r22,lo8(30)
+ 316               	.L43:
+ 317 0246 6093 0000 		sts usbTxLen,r22
+ 318               	.L34:
+ 319 024a 94E1      		ldi r25,lo8(20)
+ 320               	.L45:
+ 321 024c 89B1      		in r24,41-32
+ 322 024e 8C70      		andi r24,lo8(12)
+ 323 0250 01F4      		brne .L46
+ 324 0252 9150      		subi r25,lo8(-(-1))
+ 325 0254 01F4      		brne .L45
+ 326 0256 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
+ 327 025a 1092 0000 		sts usbDeviceAddr,__zero_reg__
+ 328               	.L46:
+ 329               	/* epilogue start */
+ 330 025e DF91      		pop r29
+ 331 0260 CF91      		pop r28
+ 332 0262 1F91      		pop r17
+ 333 0264 0895      		ret
+ 335               	.global	usbTxLen
+ 336               		.data
+ 339               	usbTxLen:
+ 340 0000 5A        		.byte	90
+ 341               	.global	usbDescriptorString0
+ 342               		.section	.progmem.data,"a",@progbits
+ 345               	usbDescriptorString0:
+ 346 0000 04        		.byte	4
+ 347 0001 03        		.byte	3
+ 348 0002 09        		.byte	9
+ 349 0003 04        		.byte	4
+ 350               		.data
+ 353               	usbMsgLen:
+ 354 0001 FF        		.byte	-1
+ 355               		.lcomm usbMsgFlags,1
+ 356               		.comm usbMsgPtr,2,1
+ 357               		.comm usbRxToken,1,1
+ 358               		.comm usbConfiguration,1,1
+ 359               		.comm usbTxStatus1,12,1
+ 360               		.comm usbRxBuf,22,1
+ 361               		.comm usbInputBufOffset,1,1
+ 362               		.comm usbDeviceAddr,1,1
+ 363               		.comm usbNewDeviceAddr,1,1
+ 364               		.comm usbRxLen,1,1
+ 365               		.comm usbCurrentTok,1,1
+ 366               		.comm usbTxBuf,11,1
+ 367               	.global __do_copy_data
+ 368               	.global __do_clear_bss
+DEFINED SYMBOLS
+                            *ABS*:00000000 usbdrv.c
+     /tmp/ccGznnCQ.s:2      *ABS*:0000003f __SREG__
+     /tmp/ccGznnCQ.s:3      *ABS*:0000003e __SP_H__
+     /tmp/ccGznnCQ.s:4      *ABS*:0000003d __SP_L__
+     /tmp/ccGznnCQ.s:5      *ABS*:00000034 __CCP__
+     /tmp/ccGznnCQ.s:6      *ABS*:00000000 __tmp_reg__
+     /tmp/ccGznnCQ.s:7      *ABS*:00000001 __zero_reg__
+     /tmp/ccGznnCQ.s:11     .text:00000000 usbInit
+                            *COM*:0000000c usbTxStatus1
+     /tmp/ccGznnCQ.s:29     .text:0000001a usbSetInterrupt
+     /tmp/ccGznnCQ.s:67     .text:0000005e usbPoll
+                            *COM*:00000001 usbRxLen
+                            *COM*:00000001 usbInputBufOffset
+                            *COM*:00000001 usbRxToken
+                            *COM*:00000016 usbRxBuf
+                            *COM*:0000000b usbTxBuf
+     /tmp/ccGznnCQ.s:339    .data:00000000 usbTxLen
+                             .bss:00000000 usbMsgFlags
+                            *COM*:00000001 usbNewDeviceAddr
+                            *COM*:00000002 usbMsgPtr
+     /tmp/ccGznnCQ.s:345    .progmem.data:00000000 usbDescriptorString0
+                            *COM*:00000001 usbConfiguration
+     /tmp/ccGznnCQ.s:353    .data:00000001 usbMsgLen
+                            *COM*:00000001 usbDeviceAddr
+                            *COM*:00000001 usbCurrentTok
+
+UNDEFINED SYMBOLS
+usbCrc16Append
+usbFunctionSetup
+usbDescriptorDevice
+usbDescriptorConfiguration
+usbFunctionDescriptor
+usbFunctionRead
+__do_copy_data
+__do_clear_bss
BinÃ¤rdateien usbdrv/usbdrv.o and /home/klaute/dev/avr/HackStick/firmware/usbdrv/usbdrv.o sind verschieden.
