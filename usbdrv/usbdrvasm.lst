   1               	# 1 "usbdrv/usbdrvasm.S"
   1               	/* Name: usbdrvasm.S
   0               	
   0               	
   2               	* Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2007-06-13
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8               	 * Revision: $Id: usbdrvasm.S 785 2010-05-30 17:57:07Z cs $
   9               	 */
  10               	
  11               	/*
  12               	General Description:
  13               	This module is the assembler part of the USB driver. This file contains
  14               	general code (preprocessor acrobatics and CRC computation) and then includes
  15               	the file appropriate for the given clock rate.
  16               	*/
  17               	
  18               	#define __SFR_OFFSET 0      /* used by avr-libc's register definitions */
  19               	#include "usbportability.h"
   1               	/* Name: usbportability.h
   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2008-06-17
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8               	 * This Revision: $Id: usbportability.h 785 2010-05-30 17:57:07Z cs $
   9               	 */
  10               	
  11               	/*
  12               	General Description:
  13               	This header is intended to contain all (or at least most of) the compiler
  14               	and library dependent stuff. The C code is written for avr-gcc and avr-libc.
  15               	The API of other development environments is converted to gcc's and avr-libc's
  16               	API by means of defines.
  17               	
  18               	This header also contains all system includes since they depend on the
  19               	development environment.
  20               	
  21               	Thanks to Oleg Semyonov for his help with the IAR tools port!
  22               	*/
  23               	
  24               	#ifndef __usbportability_h_INCLUDED__
  25               	#define __usbportability_h_INCLUDED__
  26               	
  27               	/* We check explicitly for IAR and CodeVision. Default is avr-gcc/avr-libc. */
  28               	
  29               	/* ------------------------------------------------------------------------- */
  30               	#if defined __IAR_SYSTEMS_ICC__ || defined __IAR_SYSTEMS_ASM__  /* check for IAR */
  31               	/* ------------------------------------------------------------------------- */
  32               	
  33               	#ifndef ENABLE_BIT_DEFINITIONS
  34               	#   define ENABLE_BIT_DEFINITIONS	1   /* Enable bit definitions */
  35               	#endif
  36               	
  37               	/* Include IAR headers */
  38               	#include <ioavr.h>
  39               	#ifndef __IAR_SYSTEMS_ASM__
  40               	#   include <inavr.h>
  41               	#endif
  42               	
  43               	#define __attribute__(arg)  /* not supported on IAR */
  44               	
  45               	#ifdef __IAR_SYSTEMS_ASM__
  46               	#   define __ASSEMBLER__    /* IAR does not define standard macro for asm */
  47               	#endif
  48               	
  49               	#ifdef __HAS_ELPM__
  50               	#   define PROGMEM __farflash
  51               	#else
  52               	#   define PROGMEM __flash
  53               	#endif
  54               	
  55               	#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
  56               	
  57               	/* The following definitions are not needed by the driver, but may be of some
  58               	 * help if you port a gcc based project to IAR.
  59               	 */
  60               	#define cli()       __disable_interrupt()
  61               	#define sei()       __enable_interrupt()
  62               	#define wdt_reset() __watchdog_reset()
  63               	#define _BV(x)      (1 << (x))
  64               	
  65               	/* assembler compatibility macros */
  66               	#define nop2    rjmp    $+2 /* jump to next instruction */
  67               	#define XL      r26
  68               	#define XH      r27
  69               	#define YL      r28
  70               	#define YH      r29
  71               	#define ZL      r30
  72               	#define ZH      r31
  73               	#define lo8(x)  LOW(x)
  74               	#define hi8(x)  (((x)>>8) & 0xff)   /* not HIGH to allow XLINK to make a proper range check */
  75               	
  76               	/* Depending on the device you use, you may get problems with the way usbdrv.h
  77               	 * handles the differences between devices. Since IAR does not use #defines
  78               	 * for MCU registers, we can't check for the existence of a particular
  79               	 * register with an #ifdef. If the autodetection mechanism fails, include
  80               	 * definitions for the required USB_INTR_* macros in your usbconfig.h. See
  81               	 * usbconfig-prototype.h and usbdrv.h for details.
  82               	 */
  83               	
  84               	/* ------------------------------------------------------------------------- */
  85               	#elif __CODEVISIONAVR__ /* check for CodeVision AVR */
  86               	/* ------------------------------------------------------------------------- */
  87               	/* This port is not working (yet) */
  88               	
  89               	/* #define F_CPU   _MCU_CLOCK_FREQUENCY_    seems to be defined automatically */
  90               	
  91               	#include <io.h>
  92               	#include <delay.h>
  93               	
  94               	#define __attribute__(arg)  /* not supported on IAR */
  95               	
  96               	#define PROGMEM                 __flash
  97               	#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
  98               	
  99               	#ifndef __ASSEMBLER__
 100               	static inline void  cli(void)
 101               	{
 102               	    #asm("cli");
 103               	}
 104               	static inline void  sei(void)
 105               	{
 106               	    #asm("sei");
 107               	}
 108               	#endif
 109               	#define _delay_ms(t)    delay_ms(t)
 110               	#define _BV(x)          (1 << (x))
 111               	#define USB_CFG_USE_SWITCH_STATEMENT 1  /* macro for if() cascase fails for unknown reason */
 112               	
 113               	#define macro   .macro
 114               	#define endm    .endmacro
 115               	#define nop2    rjmp    .+0 /* jump to next instruction */
 116               	
 117               	/* ------------------------------------------------------------------------- */
 118               	#else   /* default development environment is avr-gcc/avr-libc */
 119               	/* ------------------------------------------------------------------------- */
 120               	
 121               	#include <avr/io.h>
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h,v 1.52.2.28 2009/12/20 17:02:53 arcanum Exp $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    The last on-chip RAM address.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    The last possible RAM location that is addressable. This is equal to 
  75               	    RAMEND for devices that do not allow for external RAM. For devices 
  76               	    that allow external RAM, this will be larger than RAMEND.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    The last EEPROM address.
  81               	    <br>
  82               	    - \b FLASHEND
  83               	    <br>
  84               	    The last byte address in the Flash program space.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. 
  90               	    - \b E2PAGESIZE
  91               	    <br>
  92               	    The size of the EEPROM page.
  93               	    
  94               	*/
  95               	
  96               	#ifndef _AVR_IO_H_
  97               	#define _AVR_IO_H_
  98               	
  99               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
 100               	
 101               	#if defined (__AVR_AT94K__)
 102               	#  include <avr/ioat94k.h>
 103               	#elif defined (__AVR_AT43USB320__)
 104               	#  include <avr/io43u32x.h>
 105               	#elif defined (__AVR_AT43USB355__)
 106               	#  include <avr/io43u35x.h>
 107               	#elif defined (__AVR_AT76C711__)
 108               	#  include <avr/io76c711.h>
 109               	#elif defined (__AVR_AT86RF401__)
 110               	#  include <avr/io86r401.h>
 111               	#elif defined (__AVR_AT90PWM1__)
 112               	#  include <avr/io90pwm1.h>
 113               	#elif defined (__AVR_AT90PWM2__)
 114               	#  include <avr/io90pwmx.h>
 115               	#elif defined (__AVR_AT90PWM2B__)
 116               	#  include <avr/io90pwm2b.h>
 117               	#elif defined (__AVR_AT90PWM3__)
 118               	#  include <avr/io90pwmx.h>
 119               	#elif defined (__AVR_AT90PWM3B__)
 120               	#  include <avr/io90pwm3b.h>
 121               	#elif defined (__AVR_AT90PWM216__)
 122               	#  include <avr/io90pwm216.h>
 123               	#elif defined (__AVR_AT90PWM316__)
 124               	#  include <avr/io90pwm316.h>
 125               	#elif defined (__AVR_AT90PWM81__)
 126               	#  include <avr/io90pwm81.h>
 127               	#elif defined (__AVR_ATmega8U2__)
 128               	#  include <avr/iom8u2.h>
 129               	#elif defined (__AVR_ATmega16M1__)
 130               	#  include <avr/iom16m1.h>
 131               	#elif defined (__AVR_ATmega16U2__)
 132               	#  include <avr/iom16u2.h>
 133               	#elif defined (__AVR_ATmega16U4__)
 134               	#  include <avr/iom16u4.h>
 135               	#elif defined (__AVR_ATmega32C1__)
 136               	#  include <avr/iom32c1.h>
 137               	#elif defined (__AVR_ATmega32M1__)
 138               	#  include <avr/iom32m1.h>
 139               	#elif defined (__AVR_ATmega32U2__)
 140               	#  include <avr/iom32u2.h>
 141               	#elif defined (__AVR_ATmega32U4__)
 142               	#  include <avr/iom32u4.h>
 143               	#elif defined (__AVR_ATmega32U6__)
 144               	#  include <avr/iom32u6.h>
 145               	#elif defined (__AVR_ATmega64C1__)
 146               	#  include <avr/iom64c1.h>
 147               	#elif defined (__AVR_ATmega64M1__)
 148               	#  include <avr/iom64m1.h>
 149               	#elif defined (__AVR_ATmega128__)
 150               	#  include <avr/iom128.h>
 151               	#elif defined (__AVR_ATmega1280__)
 152               	#  include <avr/iom1280.h>
 153               	#elif defined (__AVR_ATmega1281__)
 154               	#  include <avr/iom1281.h>
 155               	#elif defined (__AVR_ATmega1284P__)
 156               	#  include <avr/iom1284p.h>
 157               	#elif defined (__AVR_ATmega128RFA1__)
 158               	#  include <avr/iom128rfa1.h>
 159               	#elif defined (__AVR_ATmega2560__)
 160               	#  include <avr/iom2560.h>
 161               	#elif defined (__AVR_ATmega2561__)
 162               	#  include <avr/iom2561.h>
 163               	#elif defined (__AVR_AT90CAN32__)
 164               	#  include <avr/iocan32.h>
 165               	#elif defined (__AVR_AT90CAN64__)
 166               	#  include <avr/iocan64.h>
 167               	#elif defined (__AVR_AT90CAN128__)
 168               	#  include <avr/iocan128.h>
 169               	#elif defined (__AVR_AT90USB82__)
 170               	#  include <avr/iousb82.h>
 171               	#elif defined (__AVR_AT90USB162__)
 172               	#  include <avr/iousb162.h>
 173               	#elif defined (__AVR_AT90USB646__)
 174               	#  include <avr/iousb646.h>
 175               	#elif defined (__AVR_AT90USB647__)
 176               	#  include <avr/iousb647.h>
 177               	#elif defined (__AVR_AT90USB1286__)
 178               	#  include <avr/iousb1286.h>
 179               	#elif defined (__AVR_AT90USB1287__)
 180               	#  include <avr/iousb1287.h>
 181               	#elif defined (__AVR_ATmega64__)
 182               	#  include <avr/iom64.h>
 183               	#elif defined (__AVR_ATmega640__)
 184               	#  include <avr/iom640.h>
 185               	#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
 186               	#  include <avr/iom644.h>
 187               	#elif defined (__AVR_ATmega644P__)
 188               	#  include <avr/iom644p.h>
 189               	#elif defined (__AVR_ATmega644PA__)
 190               	#  include <avr/iom644pa.h>
 191               	#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
 192               	#  include <avr/iom645.h>
 193               	#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__
 194               	#  include <avr/iom6450.h>
 195               	#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
 196               	#  include <avr/iom649.h>
 197               	#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__
 198               	#  include <avr/iom6490.h>
 199               	#elif defined (__AVR_ATmega649P__)
 200               	#  include <avr/iom649p.h>
 201               	#elif defined (__AVR_ATmega64HVE__)
 202               	#  include <avr/iom64hve.h>
 203               	#elif defined (__AVR_ATmega103__)
 204               	#  include <avr/iom103.h>
 205               	#elif defined (__AVR_ATmega32__)
 206               	#  include <avr/iom32.h>
 207               	#elif defined (__AVR_ATmega323__)
 208               	#  include <avr/iom323.h>
 209               	#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
 210               	#  include <avr/iom324.h>
 211               	#elif defined (__AVR_ATmega324PA__)
 212               	#  include <avr/iom324pa.h>
 213               	#elif defined (__AVR_ATmega325__)
 214               	#  include <avr/iom325.h>
 215               	#elif defined (__AVR_ATmega325P__)
 216               	#  include <avr/iom325.h>
 217               	#elif defined (__AVR_ATmega3250__)
 218               	#  include <avr/iom3250.h>
 219               	#elif defined (__AVR_ATmega3250P__)
 220               	#  include <avr/iom3250.h>
 221               	#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
 222               	#  include <avr/iom328p.h>
 223               	#elif defined (__AVR_ATmega329__)
 224               	#  include <avr/iom329.h>
 225               	#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
 226               	#  include <avr/iom329.h>
 227               	#elif defined (__AVR_ATmega3290__)
 228               	#  include <avr/iom3290.h>
 229               	#elif defined (__AVR_ATmega3290P__)
 230               	#  include <avr/iom3290.h>
 231               	#elif defined (__AVR_ATmega32HVB__)
 232               	#  include <avr/iom32hvb.h>
 233               	#elif defined (__AVR_ATmega406__)
 234               	#  include <avr/iom406.h>
 235               	#elif defined (__AVR_ATmega16__)
 236               	#  include <avr/iom16.h>
 237               	#elif defined (__AVR_ATmega16A__)
 238               	#  include <avr/iom16a.h>
 239               	#elif defined (__AVR_ATmega161__)
 240               	#  include <avr/iom161.h>
 241               	#elif defined (__AVR_ATmega162__)
 242               	#  include <avr/iom162.h>
 243               	#elif defined (__AVR_ATmega163__)
 244               	#  include <avr/iom163.h>
 245               	#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
 246               	#  include <avr/iom164.h>
 247               	#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
 248               	#  include <avr/iom165.h>
 249               	#elif defined (__AVR_ATmega165P__)
 250               	#  include <avr/iom165p.h>
 251               	#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
 252               	#  include <avr/iom168.h>
   1               	/* Copyright (c) 2004, Theodore A. Roth
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: iom168.h,v 1.4.2.6 2009/02/11 18:05:26 arcanum Exp $ */
  32               	
  33               	#ifndef _AVR_IOM168_H_
  34               	#define _AVR_IOM168_H_ 1
  35               	
  36               	#include <avr/iomx8.h>
   1               	/* Copyright (c) 2004,2005, Theodore A. Roth
  37               	
 253               	#elif defined (__AVR_ATmega168P__)
 254               	#  include <avr/iom168p.h>
 255               	#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
 256               	#  include <avr/iom169.h>
 257               	#elif defined (__AVR_ATmega169P__)
 258               	#  include <avr/iom169p.h>
 259               	#elif defined (__AVR_ATmega169PA__)
 260               	#  include <avr/iom169pa.h>
 261               	#elif defined (__AVR_ATmega8HVA__)
 262               	#  include <avr/iom8hva.h>
 263               	#elif defined (__AVR_ATmega16HVA__)
 264               	#  include <avr/iom16hva.h>
 265               	#elif defined (__AVR_ATmega16HVA2__)
 266               	#  include <avr/iom16hva2.h>
 267               	#elif defined (__AVR_ATmega16HVB__)
 268               	#  include <avr/iom16hvb.h>
 269               	#elif defined (__AVR_ATmega8__)
 270               	#  include <avr/iom8.h>
 271               	#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
 272               	#  include <avr/iom48.h>
 273               	#elif defined (__AVR_ATmega48P__)
 274               	#  include <avr/iom48p.h>
 275               	#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmega88A__)
 276               	#  include <avr/iom88.h>
 277               	#elif defined (__AVR_ATmega88P__)
 278               	#  include <avr/iom88p.h>
 279               	#elif defined (__AVR_ATmega88PA__)
 280               	#  include <avr/iom88pa.h>
 281               	#elif defined (__AVR_ATmega8515__)
 282               	#  include <avr/iom8515.h>
 283               	#elif defined (__AVR_ATmega8535__)
 284               	#  include <avr/iom8535.h>
 285               	#elif defined (__AVR_AT90S8535__)
 286               	#  include <avr/io8535.h>
 287               	#elif defined (__AVR_AT90C8534__)
 288               	#  include <avr/io8534.h>
 289               	#elif defined (__AVR_AT90S8515__)
 290               	#  include <avr/io8515.h>
 291               	#elif defined (__AVR_AT90S4434__)
 292               	#  include <avr/io4434.h>
 293               	#elif defined (__AVR_AT90S4433__)
 294               	#  include <avr/io4433.h>
 295               	#elif defined (__AVR_AT90S4414__)
 296               	#  include <avr/io4414.h>
 297               	#elif defined (__AVR_ATtiny22__)
 298               	#  include <avr/iotn22.h>
 299               	#elif defined (__AVR_ATtiny26__)
 300               	#  include <avr/iotn26.h>
 301               	#elif defined (__AVR_AT90S2343__)
 302               	#  include <avr/io2343.h>
 303               	#elif defined (__AVR_AT90S2333__)
 304               	#  include <avr/io2333.h>
 305               	#elif defined (__AVR_AT90S2323__)
 306               	#  include <avr/io2323.h>
 307               	#elif defined (__AVR_AT90S2313__)
 308               	#  include <avr/io2313.h>
 309               	#elif defined (__AVR_ATtiny2313__)
 310               	#  include <avr/iotn2313.h>
 311               	#elif defined (__AVR_ATtiny2313A__)
 312               	#  include <avr/iotn2313a.h>
 313               	#elif defined (__AVR_ATtiny13__)
 314               	#  include <avr/iotn13.h>
 315               	#elif defined (__AVR_ATtiny13A__)
 316               	#  include <avr/iotn13a.h>
 317               	#elif defined (__AVR_ATtiny25__)
 318               	#  include <avr/iotn25.h>
 319               	#elif defined (__AVR_ATtiny4313__)
 320               	#  include <avr/iotn4313.h>
 321               	#elif defined (__AVR_ATtiny45__)
 322               	#  include <avr/iotn45.h>
 323               	#elif defined (__AVR_ATtiny85__)
 324               	#  include <avr/iotn85.h>
 325               	#elif defined (__AVR_ATtiny24__)
 326               	#  include <avr/iotn24.h>
 327               	#elif defined (__AVR_ATtiny24A__)
 328               	#  include <avr/iotn24a.h>
 329               	#elif defined (__AVR_ATtiny44__)
 330               	#  include <avr/iotn44.h>
 331               	#elif defined (__AVR_ATtiny44A__)
 332               	#  include <avr/iotn44a.h>
 333               	#elif defined (__AVR_ATtiny84__)
 334               	#  include <avr/iotn84.h>
 335               	#elif defined (__AVR_ATtiny261__)
 336               	#  include <avr/iotn261.h>
 337               	#elif defined (__AVR_ATtiny261A__)
 338               	#  include <avr/iotn261a.h>
 339               	#elif defined (__AVR_ATtiny461__)
 340               	#  include <avr/iotn461.h>
 341               	#elif defined (__AVR_ATtiny461A__)
 342               	#  include <avr/iotn461a.h>
 343               	#elif defined (__AVR_ATtiny861__)
 344               	#  include <avr/iotn861.h>
 345               	#elif defined (__AVR_ATtiny861A__)
 346               	#  include <avr/iotn861a.h>
 347               	#elif defined (__AVR_ATtiny43U__)
 348               	#  include <avr/iotn43u.h>
 349               	#elif defined (__AVR_ATtiny48__)
 350               	#  include <avr/iotn48.h>
 351               	#elif defined (__AVR_ATtiny88__)
 352               	#  include <avr/iotn88.h>
 353               	#elif defined (__AVR_ATtiny87__)
 354               	#  include <avr/iotn87.h>
 355               	#elif defined (__AVR_ATtiny167__)
 356               	#  include <avr/iotn167.h>
 357               	#elif defined (__AVR_AT90SCR100__)
 358               	#  include <avr/io90scr100.h>
 359               	#elif defined (__AVR_ATxmega16A4__)
 360               	#  include <avr/iox16a4.h>
 361               	#elif defined (__AVR_ATxmega16D4__)
 362               	#  include <avr/iox16d4.h>
 363               	#elif defined (__AVR_ATxmega32A4__)
 364               	#  include <avr/iox32a4.h>
 365               	#elif defined (__AVR_ATxmega32D4__)
 366               	#  include <avr/iox32d4.h>
 367               	#elif defined (__AVR_ATxmega64A1__)
 368               	#  include <avr/iox64a1.h>
 369               	#elif defined (__AVR_ATxmega64A3__)
 370               	#  include <avr/iox64a3.h>
 371               	#elif defined (__AVR_ATxmega64D3__)
 372               	#  include <avr/iox64d3.h>
 373               	#elif defined (__AVR_ATxmega128A1__)
 374               	#  include <avr/iox128a1.h>
 375               	#elif defined (__AVR_ATxmega128A3__)
 376               	#  include <avr/iox128a3.h>
 377               	#elif defined (__AVR_ATxmega128D3__)
 378               	#  include <avr/iox128d3.h>
 379               	#elif defined (__AVR_ATxmega192A3__)
 380               	#  include <avr/iox192a3.h>
 381               	#elif defined (__AVR_ATxmega192D3__)
 382               	#  include <avr/iox192d3.h>
 383               	#elif defined (__AVR_ATxmega256A3__)
 384               	#  include <avr/iox256a3.h>
 385               	#elif defined (__AVR_ATxmega256A3B__)
 386               	#  include <avr/iox256a3b.h>
 387               	#elif defined (__AVR_ATxmega256D3__)
 388               	#  include <avr/iox256d3.h>
 389               	#elif defined (__AVR_ATA6289__)
 390               	#  include <avr/ioa6289.h>
 391               	/* avr1: the following only supported for assembler programs */
 392               	#elif defined (__AVR_ATtiny28__)
 393               	#  include <avr/iotn28.h>
 394               	#elif defined (__AVR_AT90S1200__)
 395               	#  include <avr/io1200.h>
 396               	#elif defined (__AVR_ATtiny15__)
 397               	#  include <avr/iotn15.h>
 398               	#elif defined (__AVR_ATtiny12__)
 399               	#  include <avr/iotn12.h>
 400               	#elif defined (__AVR_ATtiny11__)
 401               	#  include <avr/iotn11.h>
 402               	#else
 403               	#  if !defined(__COMPILING_AVR_LIBC__)
 404               	#    warning "device type not defined"
 405               	#  endif
 406               	#endif
 407               	
 408               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 409               	
 410               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 411               	
 412               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 413               	
 414               	/* Include fuse.h after individual IO header files. */
 415               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 416               	
 417               	/* Include lock.h after individual IO header files. */
 418               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 419               	
 122               	avr/pgmspace.h>
  20               	"         /* for common defs */
   1               	/* Name: usbdrv.h
   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2004-12-29
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8               	 * This Revision: $Id: usbdrv.h 793 2010-07-15 15:58:11Z cs $
   9               	 */
  10               	
  11               	#ifndef __usbdrv_h_included__
  12               	#define __usbdrv_h_included__
  13               	#include "usbconfig.h"
   1               	/* Name: usbconfig.h
  14               	portability.h"
  21               	/* register names */
  22               	#define x1      r16
  23               	#define x2      r17
  24               	#define shift   r18
  25               	#define cnt     r19
  26               	#define x3      r20
  27               	#define x4      r21
  28               	#define x5		r22
  29               	#define bitcnt  x5
  30               	#define phase   x4
  31               	#define leap    x4
  32               	
  33               	/* Some assembler dependent definitions and declarations: */
  34               	
  35               	#ifdef __IAR_SYSTEMS_ASM__
  36               	    extern  usbRxBuf, usbDeviceAddr, usbNewDeviceAddr, usbInputBufOffset
  37               	    extern  usbCurrentTok, usbRxLen, usbRxToken, usbTxLen
  38               	    extern  usbTxBuf, usbTxStatus1, usbTxStatus3
  39               	#   if USB_COUNT_SOF
  40               	        extern usbSofCount
  41               	#   endif
  42               	    public  usbCrc16
  43               	    public  usbCrc16Append
  44               	
  45               	    COMMON  INTVEC
  46               	#   ifndef USB_INTR_VECTOR
  47               	        ORG     INT0_vect
  48               	#   else /* USB_INTR_VECTOR */
  49               	        ORG     USB_INTR_VECTOR
  50               	#       undef   USB_INTR_VECTOR
  51               	#   endif /* USB_INTR_VECTOR */
  52               	#   define  USB_INTR_VECTOR usbInterruptHandler
  53               	    rjmp    USB_INTR_VECTOR
  54               	    RSEG    CODE
  55               	
  56               	#else /* __IAR_SYSTEMS_ASM__ */
  57               	
  58               	#   ifndef USB_INTR_VECTOR /* default to hardware interrupt INT0 */
  59               	#       ifdef INT0_vect
  60               	#           define USB_INTR_VECTOR  INT0_vect       // this is the "new" define for the vector
  61               	#       else
  62               	#           define USB_INTR_VECTOR  SIG_INTERRUPT0  // this is the "old" vector
  63               	#       endif
  64               	#   endif
  65               	    .text
  66               	    .global USB_INTR_VECTOR
  68               	    .global usbCrc16
  69               	    .global usbCrc16Append
  70               	#endif /* __IAR_SYSTEMS_ASM__ */
  71               	
  72               	
  73               	#if USB_INTR_PENDING < 0x40 /* This is an I/O address, use in and out */
  74               	#   define  USB_LOAD_PENDING(reg)   in reg, USB_INTR_PENDING
  75               	#   define  USB_STORE_PENDING(reg)  out USB_INTR_PENDING, reg
  76               	#else   /* It's a memory address, use lds and sts */
  77               	#   define  USB_LOAD_PENDING(reg)   lds reg, USB_INTR_PENDING
  78               	#   define  USB_STORE_PENDING(reg)  sts USB_INTR_PENDING, reg
  79               	#endif
  80               	
  81               	#define usbTxLen1   usbTxStatus1
  82               	#define usbTxBuf1   (usbTxStatus1 + 1)
  83               	#define usbTxLen3   usbTxStatus3
  84               	#define usbTxBuf3   (usbTxStatus3 + 1)
  85               	
  86               	
  87               	;----------------------------------------------------------------------------
  88               	; Utility functions
  89               	;----------------------------------------------------------------------------
  90               	
  91               	#ifdef __IAR_SYSTEMS_ASM__
  92               	/* Register assignments for usbCrc16 on IAR cc */
  93               	/* Calling conventions on IAR:
  94               	 * First parameter passed in r16/r17, second in r18/r19 and so on.
  95               	 * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
  96               	 * Result is passed in r16/r17
  97               	 * In case of the "tiny" memory model, pointers are only 8 bit with no
  98               	 * padding. We therefore pass argument 1 as "16 bit unsigned".
  99               	 */
 100               	RTMODEL "__rt_version", "3"
 101               	/* The line above will generate an error if cc calling conventions change.
 102               	 * The value "3" above is valid for IAR 4.10B/W32
 103               	 */
 104               	#   define argLen   r18 /* argument 2 */
 105               	#   define argPtrL  r16 /* argument 1 */
 106               	#   define argPtrH  r17 /* argument 1 */
 107               	
 108               	#   define resCrcL  r16 /* result */
 109               	#   define resCrcH  r17 /* result */
 110               	
 111               	#   define ptrL     ZL
 112               	#   define ptrH     ZH
 113               	#   define ptr      Z
 114               	#   define byte     r22
 115               	#   define bitCnt   r19
 116               	#   define polyL    r20
 117               	#   define polyH    r21
 118               	#   define scratch  r23
 119               	
 120               	#else  /* __IAR_SYSTEMS_ASM__ */ 
 121               	/* Register assignments for usbCrc16 on gcc */
 122               	/* Calling conventions on gcc:
 123               	 * First parameter passed in r24/r25, second in r22/23 and so on.
 124               	 * Callee must preserve r1-r17, r28/r29
 125               	 * Result is passed in r24/r25
 126               	 */
 127               	#   define argLen   r22 /* argument 2 */
 128               	#   define argPtrL  r24 /* argument 1 */
 129               	#   define argPtrH  r25 /* argument 1 */
 130               	
 131               	#   define resCrcL  r24 /* result */
 132               	#   define resCrcH  r25 /* result */
 133               	
 134               	#   define ptrL     XL
 135               	#   define ptrH     XH
 136               	#   define ptr      x
 137               	#   define byte     r18
 138               	#   define bitCnt   r19
 139               	#   define polyL    r20
 140               	#   define polyH    r21
 141               	#   define scratch  r23
 142               	
 143               	#endif
 144               	
 145               	#if USB_USE_FAST_CRC
 146               	
 147               	; This implementation is faster, but has bigger code size
 148               	; Thanks to Slawomir Fras (BoskiDialer) for this code!
 149               	; It implements the following C pseudo-code:
 150               	; unsigned table(unsigned char x)
 151               	; {
 152               	; unsigned    value;
 153               	; 
 154               	;     value = (unsigned)x << 6;
 155               	;     value ^= (unsigned)x << 7;
 156               	;     if(parity(x))
 157               	;         value ^= 0xc001;
 158               	;     return value;
 159               	; }
 160               	; unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen)
 161               	; {
 162               	; unsigned crc = 0xffff;
 163               	; 
 164               	;     while(argLen--)
 165               	;         crc = table(lo8(crc) ^ *argPtr++) ^ hi8(crc);
 166               	;     return ~crc;
 167               	; }
 168               	
 169               	; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
 170               	;   argPtr  r24+25 / r16+r17
 171               	;   argLen  r22 / r18
 172               	; temp variables:
 173               	;   byte    r18 / r22
 174               	;   scratch r23
 175               	;   resCrc  r24+r25 / r16+r17
 176               	;   ptr     X / Z
 177               	usbCrc16:
 178               	    mov     ptrL, argPtrL
 179               	    mov     ptrH, argPtrH
 180               	    ldi     resCrcL, 0xFF
 181               	    ldi     resCrcH, 0xFF
 182               	    rjmp    usbCrc16LoopTest
 183               	usbCrc16ByteLoop:
 184               	    ld      byte, ptr+
 185               	    eor     resCrcL, byte   ; resCrcL is now 'x' in table()
 186               	    mov     byte, resCrcL   ; compute parity of 'x'
 187               	    swap    byte
 188               	    eor     byte, resCrcL
 189               	    mov     scratch, byte
 190               	    lsr     byte
 191               	    lsr     byte
 192               	    eor     byte, scratch
 193               	    inc     byte
 194               	    lsr     byte
 195               	    andi    byte, 1         ; byte is now parity(x)
 196               	    mov     scratch, resCrcL
 197               	    mov     resCrcL, resCrcH
 198               	    eor     resCrcL, byte   ; low byte of if(parity(x)) value ^= 0xc001;
 199               	    neg     byte
 200               	    andi    byte, 0xc0
 201               	    mov     resCrcH, byte   ; high byte of if(parity(x)) value ^= 0xc001;
 202               	    clr     byte
 203               	    lsr     scratch
 204               	    ror     byte
 205               	    eor     resCrcH, scratch
 206               	    eor     resCrcL, byte
 207               	    lsr     scratch
 208               	    ror     byte
 209               	    eor     resCrcH, scratch
 210               	    eor     resCrcL, byte
 211               	usbCrc16LoopTest:
 212               	    subi    argLen, 1
 213               	    brsh    usbCrc16ByteLoop
 214               	    com     resCrcL
 215               	    com     resCrcH
 216               	    ret
 217               	
 218               	#else   /* USB_USE_FAST_CRC */
 219               	
 220               	; This implementation is slower, but has less code size
 221               	;
 222               	; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
 223               	;   argPtr  r24+25 / r16+r17
 224               	;   argLen  r22 / r18
 225               	; temp variables:
 226               	;   byte    r18 / r22
 227               	;   bitCnt  r19
 228               	;   poly    r20+r21
 229               	;   scratch r23
 230               	;   resCrc  r24+r25 / r16+r17
 231               	;   ptr     X / Z
 232               	usbCrc16:
 233               	    mov     ptrL, argPtrL
 234:usbdrv/usbdrvasm.S ****     mov     ptrH, argPtrH
 235:usbdrv/usbdrvasm.S ****     ldi     resCrcL, 0
 236:usbdrv/usbdrvasm.S ****     ldi     resCrcH, 0
 237:usbdrv/usbdrvasm.S ****     ldi     polyL, lo8(0xa001)
 238:usbdrv/usbdrvasm.S ****     ldi     polyH, hi8(0xa001)
 239:usbdrv/usbdrvasm.S ****     com     argLen      ; argLen = -argLen - 1: modified loop to ensure that carry is set
 240:usbdrv/usbdrvasm.S ****     ldi     bitCnt, 0   ; loop counter with starnd condition = end condition
 241:usbdrv/usbdrvasm.S ****     rjmp    usbCrcLoopEntry
 242:usbdrv/usbdrvasm.S **** usbCrcByteLoop:
 243               	    ld      byte, ptr+
 244:usbdrv/usbdrvasm.S ****     eor     resCrcL, byte
 245:usbdrv/usbdrvasm.S **** usbCrcBitLoop:
 246               	    ror     resCrcH     ; carry is always set here (see brcs jumps to here)
 247:usbdrv/usbdrvasm.S ****     ror     resCrcL
 248:usbdrv/usbdrvasm.S ****     brcs    usbCrcNoXor
 249:usbdrv/usbdrvasm.S ****     eor     resCrcL, polyL
 250:usbdrv/usbdrvasm.S ****     eor     resCrcH, polyH
 251:usbdrv/usbdrvasm.S **** usbCrcNoXor:
 252               	    subi    bitCnt, 224 ; (8 * 224) % 256 = 0; this loop iterates 8 times
 253:usbdrv/usbdrvasm.S ****     brcs    usbCrcBitLoop
 254:usbdrv/usbdrvasm.S **** usbCrcLoopEntry:
 255               	    subi    argLen, -1
 256:usbdrv/usbdrvasm.S ****     brcs    usbCrcByteLoop
 257:usbdrv/usbdrvasm.S **** usbCrcReady:
 258               	    ret
 259:usbdrv/usbdrvasm.S **** ; Thanks to Reimar Doeffinger for optimizing this CRC routine!
 260               	
 261               	#endif /* USB_USE_FAST_CRC */
 262               	
 263               	; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
 264               	usbCrc16Append:
 265               	    rcall   usbCrc16
 266:usbdrv/usbdrvasm.S ****     st      ptr+, resCrcL
 267:usbdrv/usbdrvasm.S ****     st      ptr+, resCrcH
 268:usbdrv/usbdrvasm.S ****     ret
 269:usbdrv/usbdrvasm.S **** 
 270               	#undef argLen
 271               	#undef argPtrL
 272               	#undef argPtrH
 273               	#undef resCrcL
 274               	#undef resCrcH
 275               	#undef ptrL
 276               	#undef ptrH
 277               	#undef ptr
 278               	#undef byte
 279               	#undef bitCnt
 280               	#undef polyL
 281               	#undef polyH
 282               	#undef scratch
 283               	
 284               	
 285               	#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
 286               	#ifdef __IAR_SYSTEMS_ASM__
 287               	/* Register assignments for usbMeasureFrameLength on IAR cc */
 288               	/* Calling conventions on IAR:
 289               	 * First parameter passed in r16/r17, second in r18/r19 and so on.
 290               	 * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
 291               	 * Result is passed in r16/r17
 292               	 * In case of the "tiny" memory model, pointers are only 8 bit with no
 293               	 * padding. We therefore pass argument 1 as "16 bit unsigned".
 294               	 */
 295               	#   define resL     r16
 296               	#   define resH     r17
 297               	#   define cnt16L   r30
 298               	#   define cnt16H   r31
 299               	#   define cntH     r18
 300               	
 301               	#else  /* __IAR_SYSTEMS_ASM__ */ 
 302               	/* Register assignments for usbMeasureFrameLength on gcc */
 303               	/* Calling conventions on gcc:
 304               	 * First parameter passed in r24/r25, second in r22/23 and so on.
 305               	 * Callee must preserve r1-r17, r28/r29
 306               	 * Result is passed in r24/r25
 307               	 */
 308               	#   define resL     r24
 309               	#   define resH     r25
 310               	#   define cnt16L   r24
 311               	#   define cnt16H   r25
 312               	#   define cntH     r26
 313               	#endif
 314               	#   define cnt16    cnt16L
 315               	
 316               	; extern unsigned usbMeasurePacketLength(void);
 317               	; returns time between two idle strobes in multiples of 7 CPU clocks
 318               	.global usbMeasureFrameLength
 319               	usbMeasureFrameLength:
 320               	    ldi     cntH, 6         ; wait ~ 10 ms for D- == 0
 321               	    clr     cnt16L
 322               	    clr     cnt16H
 323               	usbMFTime16:
 324               	    dec     cntH
 325               	    breq    usbMFTimeout
 326               	usbMFWaitStrobe:            ; first wait for D- == 0 (idle strobe)
 327               	    sbiw    cnt16, 1        ;[0] [6]
 328               	    breq    usbMFTime16     ;[2]
 329               	    sbic    USBIN, USBMINUS ;[3]
 330               	    rjmp    usbMFWaitStrobe ;[4]
 331               	usbMFWaitIdle:              ; then wait until idle again
 332               	    sbis    USBIN, USBMINUS ;1 wait for D- == 1
 333               	    rjmp    usbMFWaitIdle   ;2
 334               	    ldi     cnt16L, 1       ;1 represents cycles so far
 335               	    clr     cnt16H          ;1
 336               	usbMFWaitLoop:
 337               	    in      cntH, USBIN     ;[0] [7]
 338               	    adiw    cnt16, 1        ;[1]
 339               	    breq    usbMFTimeout    ;[3]
 340               	    andi    cntH, USBMASK   ;[4]
 341               	    brne    usbMFWaitLoop   ;[5]
 342               	usbMFTimeout:
 343               	#if resL != cnt16L
 344               	    mov     resL, cnt16L
 345               	    mov     resH, cnt16H
 346               	#endif
 347               	    ret
 348               	
 349               	#undef resL
 350               	#undef resH
 351               	#undef cnt16
 352               	#undef cnt16L
 353               	#undef cnt16H
 354               	#undef cntH
 355               	
 356               	#endif  /* USB_CFG_HAVE_MEASURE_FRAME_LENGTH */
 357               	
 358               	;----------------------------------------------------------------------------
 359               	; Now include the clock rate specific code
 360               	;----------------------------------------------------------------------------
 361               	
 362               	#ifndef USB_CFG_CLOCK_KHZ
 363               	#   ifdef F_CPU
 364               	#       define USB_CFG_CLOCK_KHZ (F_CPU/1000)
 365               	#error "test " USB_CFG_CLOCK_KHZ
 366               	#   else
 367               	#       error "USB_CFG_CLOCK_KHZ not defined in usbconfig.h and no F_CPU set!"
 368               	#   endif
 369               	#endif
 370               	
 371               	#if USB_CFG_CHECK_CRC   /* separate dispatcher for CRC type modules */
 372               	#   if USB_CFG_CLOCK_KHZ == 18000
 373               	#       include "usbdrvasm18-crc.inc"
 374               	#   else
 375               	#       error "USB_CFG_CLOCK_KHZ is not one of the supported crc-rates!"
 376               	#   endif
 377               	#else   /* USB_CFG_CHECK_CRC */
 378               	#   if USB_CFG_CLOCK_KHZ == 12000
 379               	#       include "usbdrvasm12.inc"
 380               	#   elif USB_CFG_CLOCK_KHZ == 12800
 381               	#       include "usbdrvasm128.inc"
 382               	#   elif USB_CFG_CLOCK_KHZ == 15000
 383               	#       include "usbdrvasm15.inc"
 384               	#   elif USB_CFG_CLOCK_KHZ == 16000
 385               	#       include "usbdrvasm16.inc"
 386               	#   elif USB_CFG_CLOCK_KHZ == 16500
 387               	#       include "usbdrvasm165.inc"
 388               	#   elif USB_CFG_CLOCK_KHZ == 20000
 389               	#       include "usbdrvasm20.inc"
 390               	#   else
   1               	/* Name: usbdrvasm20.inc
   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3               	 * Author: Jeroen Benschop
   4               	 * Based on usbdrvasm16.inc from Christian Starkjohann
   5               	 * Creation Date: 2008-03-05
   6               	 * Tabsize: 4
   7               	 * Copyright: (c) 2008 by Jeroen Benschop and OBJECTIVE DEVELOPMENT Software GmbH
   8               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   9               	 * Revision: $Id: usbdrvasm20.inc 740 2009-04-13 18:23:31Z cs $
  10               	 */
  11               	
  12               	/* Do not link this file! Link usbdrvasm.S instead, which includes the
  13               	 * appropriate implementation!
  14               	 */
  15               	
  16               	/*
  17               	General Description:
  18               	This file is the 20 MHz version of the asssembler part of the USB driver. It
  19               	requires a 20 MHz crystal (not a ceramic resonator and not a calibrated RC
  20               	oscillator).
  21               	
  22               	See usbdrv.h for a description of the entire driver.
  23               	
  24               	Since almost all of this code is timing critical, don't change unless you
  25               	really know what you are doing! Many parts require not only a maximum number
  26               	of CPU cycles, but even an exact number of cycles!
  27               	*/
  28               	
  29               	#define leap2   x3
  30               	#ifdef __IAR_SYSTEMS_ASM__
  31               	#define nextInst    $+2
  32               	#else
  33               	#define nextInst    .+0
  34               	#endif
  35               	
  36               	;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
  37               	;nominal frequency: 20 MHz -> 13.333333 cycles per bit, 106.666667 cycles per byte
  38               	; Numbers in brackets are clocks counted from center of last sync bit
  39               	; when instruction starts
  40               	;register use in receive loop:
  41               	; shift assembles the byte currently being received
  42               	; x1 holds the D+ and D- line state
  43               	; x2 holds the previous line state
  44               	; x4 (leap)  is used to add a leap cycle once every three bytes received
  45               	; X3 (leap2) is used to add a leap cycle once every three stuff bits received
  46               	; bitcnt is used to determine when a stuff bit is due
  47               	; cnt holds the number of bytes left in the receive buffer
  48               	
  49               	USB_INTR_VECTOR:
  50               	;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
  51:usbdrv/usbdrvasm20.inc ****     push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
  52:usbdrv/usbdrvasm20.inc ****     in      YL, SREG            ;[-26]
  53:usbdrv/usbdrvasm20.inc ****     push    YL                  ;[-25]
  54:usbdrv/usbdrvasm20.inc ****     push    YH                  ;[-23]
  55               	;----------------------------------------------------------------------------
  56               	; Synchronize with sync pattern:
  57               	;----------------------------------------------------------------------------
  58               	;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
  59               	;sync up with J to K edge during sync pattern -- use fastest possible loops
  60               	;The first part waits at most 1 bit long since we must be in sync pattern.
  61               	;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
  62               	;waitForJ, ensure that this prerequisite is met.
  63               	waitForJ:
  64:usbdrv/usbdrvasm20.inc ****     inc     YL
  65:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  66:usbdrv/usbdrvasm20.inc ****     brne    waitForJ        ; just make sure we have ANY timeout
  67               	waitForK:
  68               	;The following code results in a sampling window of < 1/4 bit which meets the spec.
  69:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS     ;[-19]
  70:usbdrv/usbdrvasm20.inc ****     rjmp    foundK              ;[-18]
  71:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  72:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  73:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  74:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  75:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  76:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  77:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  78:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  79:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  80:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  81:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  82:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  83:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  84:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  85:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  86:usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  87               	#if USB_COUNT_SOF
  88:usbdrv/usbdrvasm20.inc ****     lds     YL, usbSofCount
  89:usbdrv/usbdrvasm20.inc ****     inc     YL
  90:usbdrv/usbdrvasm20.inc ****     sts     usbSofCount, YL
  91:usbdrv/usbdrvasm20.inc **** #endif  /* USB_COUNT_SOF */
  92:usbdrv/usbdrvasm20.inc **** #ifdef USB_SOF_HOOK
  93:usbdrv/usbdrvasm20.inc ****     USB_SOF_HOOK
  94:usbdrv/usbdrvasm20.inc **** #endif
  95:usbdrv/usbdrvasm20.inc ****     rjmp    sofError
  96               	foundK:                         ;[-16]
  97               	;{3, 5} after falling D- edge, average delay: 4 cycles
  98               	;bit0 should be at 34 for center sampling. Currently at 4 so 30 cylces till bit 0 sample
  99               	;use 1 bit time for setup purposes, then sample again. Numbers in brackets
 100               	;are cycles from center of first sync (double K) bit after the instruction
 101:usbdrv/usbdrvasm20.inc ****     push    bitcnt              ;[-16]
 102               	;   [---]                       ;[-15]
 103:usbdrv/usbdrvasm20.inc ****     lds     YL, usbInputBufOffset;[-14]
 104               	;   [---]                       ;[-13]
 105:usbdrv/usbdrvasm20.inc ****     clr     YH                  ;[-12]
 106:usbdrv/usbdrvasm20.inc ****     subi    YL, lo8(-(usbRxBuf));[-11] [rx loop init]
 107:usbdrv/usbdrvasm20.inc ****     sbci    YH, hi8(-(usbRxBuf));[-10] [rx loop init]
 108:usbdrv/usbdrvasm20.inc ****     push    shift               ;[-9]
 109               	;   [---]                       ;[-8]
 110:usbdrv/usbdrvasm20.inc ****     ldi     shift,0x40          ;[-7] set msb to "1" so processing bit7 can be detected
 111:usbdrv/usbdrvasm20.inc ****     nop2                        ;[-6]
 112               	;   [---]                       ;[-5]
 113:usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 5           ;[-4] [rx loop init]
 114:usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
 115:usbdrv/usbdrvasm20.inc ****     rjmp    haveTwoBitsK        ;[-2]
 116:usbdrv/usbdrvasm20.inc ****     pop     shift               ;[-1] undo the push from before
 117:usbdrv/usbdrvasm20.inc ****     pop     bitcnt              ;[1] 
 118:usbdrv/usbdrvasm20.inc ****     rjmp    waitForK            ;[3] this was not the end of sync, retry
 119               	; The entire loop from waitForK until rjmp waitForK above must not exceed two
 120               	; bit times (= 27 cycles).
 121               	
 122               	;----------------------------------------------------------------------------
 123               	; push more registers and initialize values while we sample the first bits:
 124               	;----------------------------------------------------------------------------
 125               	haveTwoBitsK:
 126:usbdrv/usbdrvasm20.inc ****     push    x1                  ;[0]
 127:usbdrv/usbdrvasm20.inc ****     push    x2                  ;[2]
 128:usbdrv/usbdrvasm20.inc ****     push    x3                  ;[4] (leap2)
 129:usbdrv/usbdrvasm20.inc ****     ldi     leap2, 0x55         ;[6] add leap cycle on 2nd,5th,8th,... stuff bit
 130:usbdrv/usbdrvasm20.inc ****     push    x4                  ;[7] == leap
 131:usbdrv/usbdrvasm20.inc ****     ldi     leap, 0x55          ;[9] skip leap cycle on 2nd,5th,8th,... byte received
 132:usbdrv/usbdrvasm20.inc ****     push    cnt                 ;[10]
 133:usbdrv/usbdrvasm20.inc ****     ldi     cnt, USB_BUFSIZE    ;[12] [rx loop init]
 134:usbdrv/usbdrvasm20.inc ****     ldi     x2, 1<<USBPLUS      ;[13] current line state is K state. D+=="1", D-=="0"
 135               	bit0:       
 136:usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;[0] sample line state
 137:usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;[1] filter only D+ and D- bits
 138:usbdrv/usbdrvasm20.inc ****     rjmp    handleBit           ;[2] make bit0 14 cycles long
 139               	
 140               	;----------------------------------------------------------------------------
 141               	; Process bit7. However, bit 6 still may need unstuffing.
 142               	;----------------------------------------------------------------------------
 143               	
 144               	b6checkUnstuff:
 145:usbdrv/usbdrvasm20.inc ****     dec     bitcnt              ;[9]
 146:usbdrv/usbdrvasm20.inc ****     breq    unstuff6            ;[10]
 147               	bit7:
 148:usbdrv/usbdrvasm20.inc ****     subi    cnt, 1              ;[11] cannot use dec becaus it does not affect the carry flag
 149:usbdrv/usbdrvasm20.inc ****     brcs    overflow            ;[12] Too many bytes received. Ignore packet
 150:usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;[0] sample line state
 151:usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;[1] filter only D+ and D- bits
 152:usbdrv/usbdrvasm20.inc ****     cpse    x1, x2              ;[2] when previous line state equals current line state, handle "1"
 153:usbdrv/usbdrvasm20.inc ****     rjmp    b7handle0           ;[3] when line state differs, handle "0"
 154:usbdrv/usbdrvasm20.inc ****     sec                         ;[4]
 155:usbdrv/usbdrvasm20.inc ****     ror     shift               ;[5] shift "1" into the data
 156:usbdrv/usbdrvasm20.inc ****     st      y+, shift           ;[6] store the data into the buffer
 157:usbdrv/usbdrvasm20.inc ****     ldi     shift, 0x40         ;[7] reset data for receiving the next byte
 158:usbdrv/usbdrvasm20.inc ****     subi    leap, 0x55          ;[9] trick to introduce a leap cycle every 3 bytes
 159:usbdrv/usbdrvasm20.inc ****     brcc    nextInst            ;[10 or 11] it will fail after 85 bytes. However low speed can only
 160:usbdrv/usbdrvasm20.inc ****     dec     bitcnt              ;[11 or 12]
 161:usbdrv/usbdrvasm20.inc ****     brne    bit0                ;[12 or 13]
 162:usbdrv/usbdrvasm20.inc ****     ldi     x1, 1               ;[13 or 14] unstuffing bit 7
 163:usbdrv/usbdrvasm20.inc ****     in      bitcnt, USBIN       ;[0] sample stuff bit
 164:usbdrv/usbdrvasm20.inc ****     rjmp    unstuff             ;[1]
 165               	
 166               	b7handle0:
 167:usbdrv/usbdrvasm20.inc ****     mov     x2,x1               ;[5] Set x2 to current line state
 168:usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 6           ;[6]
 169:usbdrv/usbdrvasm20.inc ****     lsr     shift               ;[7] shift "0" into the data
 170:usbdrv/usbdrvasm20.inc ****     st      y+, shift           ;[8] store data into the buffer
 171:usbdrv/usbdrvasm20.inc ****     ldi     shift, 0x40         ;[10] reset data for receiving the next byte
 172:usbdrv/usbdrvasm20.inc ****     subi    leap, 0x55          ;[11] trick to introduce a leap cycle every 3 bytes
 173:usbdrv/usbdrvasm20.inc ****     brcs    bit0                ;[12] it will fail after 85 bytes. However low speed can only recei
 174:usbdrv/usbdrvasm20.inc ****     rjmp    bit0                ;[13]
 175               	
 176               	
 177               	;----------------------------------------------------------------------------
 178               	; Handle unstuff
 179               	; x1==0xFF indicate unstuffing bit6
 180               	;----------------------------------------------------------------------------
 181               	
 182               	unstuff6:
 183:usbdrv/usbdrvasm20.inc ****     ldi     x1,0xFF             ;[12] indicate unstuffing bit 6
 184:usbdrv/usbdrvasm20.inc ****     in      bitcnt, USBIN       ;[0]  sample stuff bit
 185:usbdrv/usbdrvasm20.inc ****     nop                         ;[1]  fix timing
 186               	unstuff:                        ;b0-5  b6   b7
 187:usbdrv/usbdrvasm20.inc ****     mov     x2,bitcnt           ;[3]  [2]  [3]  Set x2 to match line state
 188:usbdrv/usbdrvasm20.inc ****     subi    leap2, 0x55         ;[4]  [3]  [4]  delay loop
 189:usbdrv/usbdrvasm20.inc ****     brcs    nextInst            ;[5]  [4]  [5]  add one cycle every three stuff bits
 190:usbdrv/usbdrvasm20.inc ****     sbci    leap2,0             ;[6]  [5]  [6]
 191:usbdrv/usbdrvasm20.inc ****     ldi     bitcnt,6            ;[7]  [6]  [7]  reset bit stuff counter
 192:usbdrv/usbdrvasm20.inc ****     andi    x2, USBMASK         ;[8]  [7]  [8] only keep D+ and D-
 193:usbdrv/usbdrvasm20.inc ****     cpi     x1,0                ;[9]  [8]  [9]
 194:usbdrv/usbdrvasm20.inc ****     brmi    bit7                ;[10] [9]  [10] finished unstuffing bit6 When x1<0
 195:usbdrv/usbdrvasm20.inc ****     breq    bitloop             ;[11] ---  [11] finished unstuffing bit0-5 when x1=0
 196:usbdrv/usbdrvasm20.inc ****     nop                         ;---  ---  [12]
 197:usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;---  ---  [0] sample line state for bit0
 198:usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;---  ---  [1] filter only D+ and D- bits
 199:usbdrv/usbdrvasm20.inc ****     rjmp    handleBit           ;---  ---  [2] make bit0 14 cycles long
 200               	
 201               	;----------------------------------------------------------------------------
 202               	; Receiver loop (numbers in brackets are cycles within byte after instr)
 203               	;----------------------------------------------------------------------------
 204               	bitloop:
 205:usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;[0] sample line state
 206:usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;[1] filter only D+ and D- bits
 207:usbdrv/usbdrvasm20.inc ****     breq    se0                 ;[2] both lines are low so handle se0
 208               	handleBit:
 209:usbdrv/usbdrvasm20.inc ****     cpse    x1, x2              ;[3] when previous line state equals current line state, handle "1"
 210:usbdrv/usbdrvasm20.inc ****     rjmp    handle0             ;[4] when line state differs, handle "0"
 211:usbdrv/usbdrvasm20.inc ****     sec                         ;[5]
 212:usbdrv/usbdrvasm20.inc ****     ror     shift               ;[6] shift "1" into the data
 213:usbdrv/usbdrvasm20.inc ****     brcs    b6checkUnstuff      ;[7] When after shift C is set, next bit is bit7
 214:usbdrv/usbdrvasm20.inc ****     nop2                        ;[8]
 215:usbdrv/usbdrvasm20.inc ****     dec     bitcnt              ;[10]
 216:usbdrv/usbdrvasm20.inc ****     brne    bitloop             ;[11]
 217:usbdrv/usbdrvasm20.inc ****     ldi     x1,0                ;[12] indicate unstuff for bit other than bit6 or bit7
 218:usbdrv/usbdrvasm20.inc ****     in      bitcnt, USBIN       ;[0] sample stuff bit
 219:usbdrv/usbdrvasm20.inc ****     rjmp    unstuff             ;[1]
 220               	
 221               	handle0:
 222:usbdrv/usbdrvasm20.inc ****     mov     x2, x1              ;[6] Set x2 to current line state
 223:usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 6           ;[7] reset unstuff counter. 
 224:usbdrv/usbdrvasm20.inc ****     lsr     shift               ;[8] shift "0" into the data
 225:usbdrv/usbdrvasm20.inc ****     brcs    bit7                ;[9] When after shift C is set, next bit is bit7
 226:usbdrv/usbdrvasm20.inc ****     nop                         ;[10]
 227:usbdrv/usbdrvasm20.inc ****     rjmp    bitloop             ;[11] 
 228               	    
 229               	;----------------------------------------------------------------------------
 230               	; End of receive loop. Now start handling EOP
 231               	;----------------------------------------------------------------------------
 232               	
 233               	macro POP_STANDARD ; 14 cycles
 234               	    pop     cnt
 235               	    pop     x4
 236               	    pop     x3
 237               	    pop     x2
 238               	    pop     x1
 239               	    pop     shift
 240               	    pop     bitcnt
 241               	    endm
 242               	macro POP_RETI     ; 7 cycles
 243               	    pop     YH
 244               	    pop     YL
 245               	    out     SREG, YL
 246               	    pop     YL
 247               	    endm
 248               	
 249               	
 250               	
 251               	#include "asmcommon.inc"
   1               	/* Name: asmcommon.inc
   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2007-11-05
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8               	 * Revision: $Id$
   9               	 */
  10               	
  11               	/* Do not link this file! Link usbdrvasm.S instead, which includes the
  12               	 * appropriate implementation!
  13               	 */
  14               	
  15               	/*
  16               	General Description:
  17               	This file contains assembler code which is shared among the USB driver
  18               	implementations for different CPU cocks. Since the code must be inserted
  19               	in the middle of the module, it's split out into this file and #included.
  20               	
  21               	Jump destinations called from outside:
  22               	    sofError: Called when no start sequence was found.
  23               	    se0: Called when a package has been successfully received.
  24               	    overflow: Called when receive buffer overflows.
  25               	    doReturn: Called after sending data.
  26               	
  27               	Outside jump destinations used by this module:
  28               	    waitForJ: Called to receive an already arriving packet.
  29               	    sendAckAndReti:
  30               	    sendNakAndReti:
  31               	    sendCntAndReti:
  32               	    usbSendAndReti:
  33               	
  34               	The following macros must be defined before this file is included:
  35               	    .macro POP_STANDARD
  36               	    .endm
  37               	    .macro POP_RETI
  38               	    .endm
  39               	*/
  40               	
  41               	#define token   x1
  42               	
  43               	overflow:
  44:usbdrv/asmcommon.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT
  45:usbdrv/asmcommon.inc ****     USB_STORE_PENDING(x2)       ; clear any pending interrupts
  46               	ignorePacket:
  47:usbdrv/asmcommon.inc ****     clr     token
  48:usbdrv/asmcommon.inc ****     rjmp    storeTokenAndReturn
  49               	
  50               	;----------------------------------------------------------------------------
  51               	; Processing of received packet (numbers in brackets are cycles after center of SE0)
  52               	;----------------------------------------------------------------------------
  53               	;This is the only non-error exit point for the software receiver loop
  54               	;we don't check any CRCs here because there is no time left.
  55               	se0:
  56:usbdrv/asmcommon.inc ****     subi    cnt, USB_BUFSIZE    ;[5]
  57:usbdrv/asmcommon.inc ****     neg     cnt                 ;[6]
  58:usbdrv/asmcommon.inc ****     sub     YL, cnt             ;[7]
  59:usbdrv/asmcommon.inc ****     sbci    YH, 0               ;[8]
  60:usbdrv/asmcommon.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
  61:usbdrv/asmcommon.inc ****     USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
  62:usbdrv/asmcommon.inc ****     ld      token, y            ;[11]
  63:usbdrv/asmcommon.inc ****     cpi     token, USBPID_DATA0 ;[13]
  64:usbdrv/asmcommon.inc ****     breq    handleData          ;[14]
  65:usbdrv/asmcommon.inc ****     cpi     token, USBPID_DATA1 ;[15]
  66:usbdrv/asmcommon.inc ****     breq    handleData          ;[16]
  67:usbdrv/asmcommon.inc ****     lds     shift, usbDeviceAddr;[17]
  68:usbdrv/asmcommon.inc ****     ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
  69:usbdrv/asmcommon.inc ****     lsl     x2                  ;[21] shift out 1 bit endpoint number
  70:usbdrv/asmcommon.inc ****     cpse    x2, shift           ;[22]
  71:usbdrv/asmcommon.inc ****     rjmp    ignorePacket        ;[23]
  72               	/* only compute endpoint number in x3 if required later */
  73               	#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
  74:usbdrv/asmcommon.inc ****     ldd     x3, y+2             ;[24] endpoint number + crc
  75:usbdrv/asmcommon.inc ****     rol     x3                  ;[26] shift in LSB of endpoint
  76               	#endif
  77:usbdrv/asmcommon.inc ****     cpi     token, USBPID_IN    ;[27]
  78:usbdrv/asmcommon.inc ****     breq    handleIn            ;[28]
  79:usbdrv/asmcommon.inc ****     cpi     token, USBPID_SETUP ;[29]
  80:usbdrv/asmcommon.inc ****     breq    handleSetupOrOut    ;[30]
  81:usbdrv/asmcommon.inc ****     cpi     token, USBPID_OUT   ;[31]
  82:usbdrv/asmcommon.inc ****     brne    ignorePacket        ;[32] must be ack, nak or whatever
  83               	;   rjmp    handleSetupOrOut    ; fallthrough
  84               	
  85               	;Setup and Out are followed by a data packet two bit times (16 cycles) after
  86               	;the end of SE0. The sync code allows up to 40 cycles delay from the start of
  87               	;the sync pattern until the first bit is sampled. That's a total of 56 cycles.
  88               	handleSetupOrOut:               ;[32]
  89               	#if USB_CFG_IMPLEMENT_FN_WRITEOUT   /* if we have data for endpoint != 0, set usbCurrentTok to addr
  90               	    andi    x3, 0xf             ;[32]
  91               	    breq    storeTokenAndReturn ;[33]
  92               	    mov     token, x3           ;[34] indicate that this is endpoint x OUT
  93               	#endif
  94               	storeTokenAndReturn:
  95:usbdrv/asmcommon.inc ****     sts     usbCurrentTok, token;[35]
  96               	doReturn:
  97:usbdrv/asmcommon.inc ****     POP_STANDARD                ;[37] 12...16 cycles
  98:usbdrv/asmcommon.inc ****     USB_LOAD_PENDING(YL)        ;[49]
  99:usbdrv/asmcommon.inc ****     sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
 100:usbdrv/asmcommon.inc ****     rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pendin
 101               	sofError:
 102:usbdrv/asmcommon.inc ****     POP_RETI                    ;macro call
 103:usbdrv/asmcommon.inc ****     reti
 104               	
 105               	handleData:
 106               	#if USB_CFG_CHECK_CRC
 107               	    CRC_CLEANUP_AND_CHECK       ; jumps to ignorePacket if CRC error
 108               	#endif
 109:usbdrv/asmcommon.inc ****     lds     shift, usbCurrentTok;[18]
 110:usbdrv/asmcommon.inc ****     tst     shift               ;[20]
 111:usbdrv/asmcommon.inc ****     breq    doReturn            ;[21]
 112:usbdrv/asmcommon.inc ****     lds     x2, usbRxLen        ;[22]
 113:usbdrv/asmcommon.inc ****     tst     x2                  ;[24]
 114:usbdrv/asmcommon.inc ****     brne    sendNakAndReti      ;[25]
 115               	; 2006-03-11: The following two lines fix a problem where the device was not
 116               	; recognized if usbPoll() was called less frequently than once every 4 ms.
 117:usbdrv/asmcommon.inc ****     cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and a
 118:usbdrv/asmcommon.inc ****     brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
 119               	#if USB_CFG_CHECK_DATA_TOGGLING
 120               	    sts     usbCurrentDataToken, token  ; store for checking by C code
 121               	#endif
 122:usbdrv/asmcommon.inc ****     sts     usbRxLen, cnt       ;[28] store received data, swap buffers
 123:usbdrv/asmcommon.inc ****     sts     usbRxToken, shift   ;[30]
 124:usbdrv/asmcommon.inc ****     lds     x2, usbInputBufOffset;[32] swap buffers
 125:usbdrv/asmcommon.inc ****     ldi     cnt, USB_BUFSIZE    ;[34]
 126:usbdrv/asmcommon.inc ****     sub     cnt, x2             ;[35]
 127:usbdrv/asmcommon.inc ****     sts     usbInputBufOffset, cnt;[36] buffers now swapped
 128:usbdrv/asmcommon.inc ****     rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
 129               	
 130               	handleIn:
 131               	;We don't send any data as long as the C code has not processed the current
 132               	;input data and potentially updated the output data. That's more efficient
 133               	;in terms of code size than clearing the tx buffers when a packet is received.
 134:usbdrv/asmcommon.inc ****     lds     x1, usbRxLen        ;[30]
 135:usbdrv/asmcommon.inc ****     cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
 136:usbdrv/asmcommon.inc ****     brge    sendNakAndReti      ;[33] unprocessed input packet?
 137:usbdrv/asmcommon.inc ****     ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
 138               	#if USB_CFG_HAVE_INTRIN_ENDPOINT
 139:usbdrv/asmcommon.inc ****     andi    x3, 0xf             ;[35] x3 contains endpoint
 140               	#if USB_CFG_SUPPRESS_INTR_CODE
 141               	    brne    sendNakAndReti      ;[36]
 142               	#else
 143:usbdrv/asmcommon.inc ****     brne    handleIn1           ;[36]
 144               	#endif
 145               	#endif
 146:usbdrv/asmcommon.inc ****     lds     cnt, usbTxLen       ;[37]
 147:usbdrv/asmcommon.inc ****     sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
 148:usbdrv/asmcommon.inc ****     rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
 149:usbdrv/asmcommon.inc ****     sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
 150:usbdrv/asmcommon.inc ****     ldi     YL, lo8(usbTxBuf)   ;[43]
 151:usbdrv/asmcommon.inc ****     ldi     YH, hi8(usbTxBuf)   ;[44]
 152:usbdrv/asmcommon.inc ****     rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
 153               	
 154               	; Comment about when to set usbTxLen to USBPID_NAK:
 155               	; We should set it back when we receive the ACK from the host. This would
 156               	; be simple to implement: One static variable which stores whether the last
 157               	; tx was for endpoint 0 or 1 and a compare in the receiver to distinguish the
 158               	; ACK. However, we set it back immediately when we send the package,
 159               	; assuming that no error occurs and the host sends an ACK. We save one byte
 160               	; RAM this way and avoid potential problems with endless retries. The rest of
 161               	; the driver assumes error-free transfers anyway.
 162               	
 163               	#if !USB_CFG_SUPPRESS_INTR_CODE && USB_CFG_HAVE_INTRIN_ENDPOINT /* placed here due to relative jump
 164               	handleIn1:                      ;[38]
 165               	#if USB_CFG_HAVE_INTRIN_ENDPOINT3
 166               	; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
 167               	    cpi     x3, USB_CFG_EP3_NUMBER;[38]
 168               	    breq    handleIn3           ;[39]
 169               	#endif
 170:usbdrv/asmcommon.inc ****     lds     cnt, usbTxLen1      ;[40]
 171:usbdrv/asmcommon.inc ****     sbrc    cnt, 4              ;[42] all handshake tokens have bit 4 set
 172:usbdrv/asmcommon.inc ****     rjmp    sendCntAndReti      ;[43] 47 + 16 = 63 until SOP
 173:usbdrv/asmcommon.inc ****     sts     usbTxLen1, x1       ;[44] x1 == USBPID_NAK from above
 174:usbdrv/asmcommon.inc ****     ldi     YL, lo8(usbTxBuf1)  ;[46]
 175:usbdrv/asmcommon.inc ****     ldi     YH, hi8(usbTxBuf1)  ;[47]
 176:usbdrv/asmcommon.inc ****     rjmp    usbSendAndReti      ;[48] 50 + 12 = 62 until SOP
 177               	
 252               	1), (D- = 0)
 253               	; Spec allows 7.5 bit times from EOP to SOP for replies
 254               	; 7.5 bit times is 100 cycles. This implementation arrives a bit later at se0
 255               	; then specified in the include file but there is plenty of time
 256               	
 257               	bitstuffN:
 258               	    eor     x1, x4          ;[8]
 259               	    ldi     x2, 0           ;[9]
 260               	    nop2                    ;[10]
 261               	    out     USBOUT, x1      ;[12] <-- out
 262:usbdrv/usbdrvasm20.inc ****     rjmp    didStuffN       ;[0]
 263:usbdrv/usbdrvasm20.inc ****     
 264:usbdrv/usbdrvasm20.inc **** bitstuff7:
 265:usbdrv/usbdrvasm20.inc ****     eor     x1, x4          ;[6]
 266:usbdrv/usbdrvasm20.inc ****     ldi     x2, 0           ;[7] Carry is zero due to brcc
 267               	    rol     shift           ;[8] compensate for ror shift at branch destination
 268               	    nop2                    ;[9]
 269:usbdrv/usbdrvasm20.inc ****     rjmp    didStuff7       ;[11]
 270:usbdrv/usbdrvasm20.inc **** 
 271:usbdrv/usbdrvasm20.inc **** sendNakAndReti:
 272:usbdrv/usbdrvasm20.inc ****     ldi     x3, USBPID_NAK  ;[-18]
 273:usbdrv/usbdrvasm20.inc ****     rjmp    sendX3AndReti   ;[-17]
 274               	sendAckAndReti:
 275               	    ldi     cnt, USBPID_ACK ;[-17]
 276:usbdrv/usbdrvasm20.inc **** sendCntAndReti:
 277:usbdrv/usbdrvasm20.inc ****     mov     x3, cnt         ;[-16]
 278               	sendX3AndReti:
 279:usbdrv/usbdrvasm20.inc ****     ldi     YL, 20          ;[-15] x3==r20 address is 20
 280               	    ldi     YH, 0           ;[-14]
 281:usbdrv/usbdrvasm20.inc ****     ldi     cnt, 2          ;[-13]
 282               	;   rjmp    usbSendAndReti      fallthrough
 283:usbdrv/usbdrvasm20.inc **** 
 284:usbdrv/usbdrvasm20.inc **** ;usbSend:
 285:usbdrv/usbdrvasm20.inc **** ;pointer to data in 'Y'
 286               	;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
 287               	;uses: x1...x4, btcnt, shift, cnt, Y
 288               	;Numbers in brackets are time since first bit of sync pattern is sent
 289               	;We don't match the transfer rate exactly (don't insert leap cycles every third
 290               	;byte) because the spec demands only 1.5% precision anyway.
 291               	usbSendAndReti:             ; 12 cycles until SOP
 292               	    in      x2, USBDDR      ;[-12]
 293               	    ori     x2, USBMASK     ;[-11]
 294               	    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
 295               	    in      x1, USBOUT      ;[-8] port mirror for tx loop
 296:usbdrv/usbdrvasm20.inc ****     out     USBDDR, x2      ;[-7] <- acquire bus
 297:usbdrv/usbdrvasm20.inc **** ; need not init x2 (bitstuff history) because sync starts with 0
 298:usbdrv/usbdrvasm20.inc ****     ldi     x4, USBMASK     ;[-6] exor mask
 299:usbdrv/usbdrvasm20.inc ****     ldi     shift, 0x80     ;[-5] sync byte is first byte sent
 300:usbdrv/usbdrvasm20.inc **** txByteLoop:
 301               	    ldi     bitcnt, 0x49    ;[-4]        [10] binary 01001001
 302:usbdrv/usbdrvasm20.inc **** txBitLoop:
 303:usbdrv/usbdrvasm20.inc ****     sbrs    shift, 0        ;[-3] [10]   [11]
 304               	    eor     x1, x4          ;[-2] [11]   [12]
 305:usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[-1] [12]   [13]   <-- out N
 306               	    ror     shift           ;[0]  [13]   [14]
 307:usbdrv/usbdrvasm20.inc ****     ror     x2              ;[1]
 308:usbdrv/usbdrvasm20.inc **** didStuffN:
 309:usbdrv/usbdrvasm20.inc ****     nop2                    ;[2]
 310:usbdrv/usbdrvasm20.inc ****     nop                     ;[4]
 311:usbdrv/usbdrvasm20.inc ****     cpi     x2, 0xfc        ;[5]
 312               	    brcc    bitstuffN       ;[6]
 313:usbdrv/usbdrvasm20.inc ****     lsr     bitcnt          ;[7]
 314:usbdrv/usbdrvasm20.inc ****     brcc    txBitLoop       ;[8]
 315:usbdrv/usbdrvasm20.inc ****     brne    txBitLoop       ;[9]
 316:usbdrv/usbdrvasm20.inc **** 
 317:usbdrv/usbdrvasm20.inc ****     sbrs    shift, 0        ;[10]
 318:usbdrv/usbdrvasm20.inc ****     eor     x1, x4          ;[11]
 319:usbdrv/usbdrvasm20.inc **** didStuff7:
 320               	    out     USBOUT, x1      ;[-1] [13] <-- out 7
 321:usbdrv/usbdrvasm20.inc ****     ror     shift           ;[0] [14]
 322:usbdrv/usbdrvasm20.inc ****     ror     x2              ;[1]
 323               	    nop                     ;[2]
 324:usbdrv/usbdrvasm20.inc ****     cpi     x2, 0xfc        ;[3]
 325:usbdrv/usbdrvasm20.inc ****     brcc    bitstuff7       ;[4]
 326:usbdrv/usbdrvasm20.inc ****     ld      shift, y+       ;[5]
 327:usbdrv/usbdrvasm20.inc ****     dec     cnt             ;[7]
 328:usbdrv/usbdrvasm20.inc ****     brne    txByteLoop      ;[8]
 329:usbdrv/usbdrvasm20.inc **** ;make SE0:
 330:usbdrv/usbdrvasm20.inc ****     cbr     x1, USBMASK     ;[9] prepare SE0 [spec says EOP may be 25 to 30 cycles]
 331:usbdrv/usbdrvasm20.inc ****     lds     x2, usbNewDeviceAddr;[10]
 332:usbdrv/usbdrvasm20.inc ****     lsl     x2              ;[12] we compare with left shifted address
 333               	    out     USBOUT, x1      ;[13] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
 334:usbdrv/usbdrvasm20.inc ****     subi    YL, 20 + 2      ;[0] Only assign address on data packets, not ACK/NAK in x3
 335:usbdrv/usbdrvasm20.inc ****     sbci    YH, 0           ;[1]
 336:usbdrv/usbdrvasm20.inc **** ;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
 337:usbdrv/usbdrvasm20.inc **** ;set address only after data packet was sent, not after handshake
 338:usbdrv/usbdrvasm20.inc ****     breq    skipAddrAssign  ;[2]
 339:usbdrv/usbdrvasm20.inc ****     sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
 340               	skipAddrAssign:
 341               	;end of usbDeviceAddress transfer
 342:usbdrv/usbdrvasm20.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
 343:usbdrv/usbdrvasm20.inc ****     USB_STORE_PENDING(x2)   ;[5]
 344               	    ori     x1, USBIDLE     ;[6]
 345               	    in      x2, USBDDR      ;[7]
 346:usbdrv/usbdrvasm20.inc ****     cbr     x2, USBMASK     ;[8] set both pins to input
 347:usbdrv/usbdrvasm20.inc ****     mov     x3, x1          ;[9]
 348:usbdrv/usbdrvasm20.inc ****     cbr     x3, USBMASK     ;[10] configure no pullup on both pins
 349:usbdrv/usbdrvasm20.inc ****     ldi     x4, 5           ;[11]
 350:usbdrv/usbdrvasm20.inc **** se0Delay:
 351:usbdrv/usbdrvasm20.inc ****     dec     x4              ;[12] [15] [18] [21] [24]
 352:usbdrv/usbdrvasm20.inc ****     brne    se0Delay        ;[13] [16] [19] [22] [25]
 353:usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[26] <-- out J (idle) -- end of SE0 (EOP signal)
 354               	    out     USBDDR, x2      ;[27] <-- release bus now
 355:usbdrv/usbdrvasm20.inc ****     out     USBOUT, x3      ;[28] <-- ensure no pull-up resistors are active
 356:usbdrv/usbdrvasm20.inc ****     rjmp    doReturn
 357:usbdrv/usbdrvasm20.inc **** ...
DEFINED SYMBOLS
usbdrv/usbdrvasm20.inc:49     .text:00000032 __vector_1
  usbdrv/usbdrvasm.S:233    .text:00000000 usbCrc16
  usbdrv/usbdrvasm.S:265    .text:0000002a usbCrc16Append
  usbdrv/usbdrvasm.S:255    .text:00000024 usbCrcLoopEntry
  usbdrv/usbdrvasm.S:243    .text:00000012 usbCrcByteLoop
  usbdrv/usbdrvasm.S:246    .text:00000016 usbCrcBitLoop
  usbdrv/usbdrvasm.S:252    .text:00000020 usbCrcNoXor
  usbdrv/usbdrvasm.S:258    .text:00000028 usbCrcReady
usbdrv/usbdrvasm20.inc:63     .text:0000003a waitForJ
usbdrv/usbdrvasm20.inc:67     .text:00000040 waitForK
usbdrv/usbdrvasm20.inc:96     .text:00000066 foundK
usbdrv/asmcommon.inc:101    .text:0000016c sofError
usbdrv/usbdrvasm20.inc:125    .text:00000084 haveTwoBitsK
usbdrv/usbdrvasm20.inc:135    .text:00000096 bit0
usbdrv/usbdrvasm20.inc:208    .text:000000f8 handleBit
usbdrv/usbdrvasm20.inc:144    .text:0000009c b6checkUnstuff
usbdrv/usbdrvasm20.inc:182    .text:000000d2 unstuff6
usbdrv/usbdrvasm20.inc:147    .text:000000a0 bit7
usbdrv/asmcommon.inc:43     .text:0000011a overflow
usbdrv/usbdrvasm20.inc:166    .text:000000c2 b7handle0
usbdrv/usbdrvasm20.inc:186    .text:000000d8 unstuff
usbdrv/usbdrvasm20.inc:204    .text:000000f2 bitloop
usbdrv/asmcommon.inc:55     .text:00000122 se0
usbdrv/usbdrvasm20.inc:221    .text:0000010e handle0
usbdrv/asmcommon.inc:46     .text:0000011e ignorePacket
usbdrv/asmcommon.inc:94     .text:00000154 storeTokenAndReturn
usbdrv/asmcommon.inc:105    .text:00000176 handleData
usbdrv/asmcommon.inc:130    .text:000001a0 handleIn
usbdrv/asmcommon.inc:88     .text:00000154 handleSetupOrOut
usbdrv/asmcommon.inc:96     .text:00000158 doReturn
usbdrv/usbdrvasm20.inc:275    .text:000001e6 sendNakAndReti
usbdrv/usbdrvasm20.inc:278    .text:000001ea sendAckAndReti
usbdrv/asmcommon.inc:164    .text:000001c0 handleIn1
usbdrv/usbdrvasm20.inc:280    .text:000001ec sendCntAndReti
usbdrv/usbdrvasm20.inc:295    .text:000001f4 usbSendAndReti
usbdrv/usbdrvasm20.inc:261    .text:000001d2 bitstuffN
usbdrv/usbdrvasm20.inc:312    .text:0000020e didStuffN
usbdrv/usbdrvasm20.inc:268    .text:000001dc bitstuff7
usbdrv/usbdrvasm20.inc:323    .text:00000220 didStuff7
usbdrv/usbdrvasm20.inc:282    .text:000001ee sendX3AndReti
usbdrv/usbdrvasm20.inc:304    .text:00000202 txByteLoop
usbdrv/usbdrvasm20.inc:306    .text:00000204 txBitLoop
usbdrv/usbdrvasm20.inc:344    .text:00000246 skipAddrAssign
usbdrv/usbdrvasm20.inc:354    .text:00000256 se0Delay

UNDEFINED SYMBOLS
usbInputBufOffset
usbRxBuf
usbDeviceAddr
usbCurrentTok
usbRxLen
usbRxToken
usbTxLen
usbTxBuf
usbTxStatus1
usbNewDeviceAddr
